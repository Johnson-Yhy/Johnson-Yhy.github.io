<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Data-Struct code | Johnson-Yhy🥝</title><meta name="author" content="Johnson-Yhy🍭"><meta name="copyright" content="Johnson-Yhy🍭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="建议缩小屏幕宽度来更好的查看全部代码   这是  接下来当你遇到报错时的抓拍。 顺序表-Sequence table 顺序表                                顺序表-(静态分配)                             123456789101112131415161718192021222324252627#include&lt;iostream&amp;g">
<meta property="og:type" content="article">
<meta property="og:title" content="Data-Struct code">
<meta property="og:url" content="http://example.com/2023/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81/index.html">
<meta property="og:site_name" content="Johnson-Yhy🥝">
<meta property="og:description" content="建议缩小屏幕宽度来更好的查看全部代码   这是  接下来当你遇到报错时的抓拍。 顺序表-Sequence table 顺序表                                顺序表-(静态分配)                             123456789101112131415161718192021222324252627#include&lt;iostream&amp;g">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images7.alphacoders.com/130/1306240.jpg">
<meta property="article:published_time" content="2023-10-14T16:00:00.000Z">
<meta property="article:modified_time" content="2023-10-15T05:14:14.545Z">
<meta property="article:author" content="Johnson-Yhy🍭">
<meta property="article:tag" content="🥧c plus plus">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images7.alphacoders.com/130/1306240.jpg"><link rel="shortcut icon" href="/image/touxiang.jpg"><link rel="canonical" href="http://example.com/2023/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":300,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":100},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Data-Struct code',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-15 13:14:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><link rel="stylesheet" href="/css/cat.css"><span id="fps"></span><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/cebian.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/readPercent.css"><link rel="stylesheet" href="/css/friendlink.css"><link rel="stylesheet" href="/css/VolantisTags.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,300&display=swap" rel="stylesheet"><link rel="stylesheet" href="/css/font.css"><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 网站</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影院</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images7.alphacoders.com/130/1306240.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Johnson-Yhy🥝"><span class="site-name">Johnson-Yhy🥝</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 网站</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影院</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Data-Struct code</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-14T16:00:00.000Z" title="发表于 2023-10-15 00:00:00">2023-10-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-15T05:14:14.545Z" title="更新于 2023-10-15 13:14:14">2023-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%F0%9F%8E%88c-puls-plus/">🎈c puls plus</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Data-Struct code"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"></svg><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>建议缩小屏幕宽度来更好的查看全部代码 <img no-lazy class="inline" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1.itc.cn/q_70/images03/20220922/da0879303f5a4c03b3ae85d8b259ca16.gif" style="height:50px;"/> </p>
<p>这是 <img no-lazy class="inline" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hiphotos.baidu.com/feed/pic/item/4b90f603738da9772a71541dbd51f8198618e3ae.jpg" style="height:50px;"/> 接下来当你遇到报错时的抓拍。</p>
<h1 id="顺序表-Sequence-table"><a href="#顺序表-Sequence-table" class="headerlink" title="顺序表-Sequence table"></a>顺序表-Sequence table</h1><details class="folding-tag" yellow><summary> 顺序表 </summary>
              <div class='content'>
              <details class="folding-tag" blue><summary> 顺序表-(静态分配) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   <span class="comment">//定义顺序表最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;		<span class="comment">//顺序表的类型定义</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize];		<span class="comment">//用数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length;			<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作---初始化一个顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList1</span><span class="params">(SeqList&amp; L)</span> </span>&#123;</span><br><span class="line">	L.length = <span class="number">0</span>;		<span class="comment">//必须设置顺序表的初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SeqList L;			<span class="comment">//声明一个顺序表</span></span><br><span class="line">	<span class="built_in">InitList1</span>(L);		<span class="comment">//初始化顺序表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这种访问方式是违规的，不能访问大于当前顺序表长度的数据i&lt;L.length</span></span><br><span class="line">	<span class="comment">//使用i&lt;L.length也不够好，应该使用基本操作来访问各个数据元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++)			</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;data[i]=&quot;</span>&lt;&lt;L.data[i]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" pink><summary> 顺序表-(动态分配) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitList(SeqList&amp; L);							//1.初始化顺序表</span></span><br><span class="line"><span class="comment">// int Length(SeqList L);								//2.求表长</span></span><br><span class="line"><span class="comment">// bool Empty(SeqList L);								//3.判空</span></span><br><span class="line"><span class="comment">// void IncreaseSize(SeqList&amp; L, int len);				//4.增加动态数组的长度</span></span><br><span class="line"><span class="comment">// bool InsertList(SeqList&amp; L, int i, ElemType e);		//5.插入操作</span></span><br><span class="line"><span class="comment">// bool ListDelete(SeqList&amp; L, int i, ElemType&amp; e);	//6.删除操作</span></span><br><span class="line"><span class="comment">// ElemType GetElem(SeqList L, int i);					//7-1.查找操作-按位查找</span></span><br><span class="line"><span class="comment">// int LocateElem(SeqList L, ElemType e);				//7-2.查找操作-按值查找</span></span><br><span class="line"><span class="comment">// void PrintList(SeqList L);							//8.遍历</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10	   <span class="comment">//定义顺序表的初始长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int   <span class="comment">//定义数据元素类型</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	02.顺序表_动态分配(malloc函数实现)</span></span><br><span class="line"><span class="comment">		1.sizeof(类型符或变量名)</span></span><br><span class="line"><span class="comment">			（1）当操作数为数据类型时，得到该数据类型的存储字节数</span></span><br><span class="line"><span class="comment">			（2）当操作数为变量名时，得到变量使用的存储单元字节数</span></span><br><span class="line"><span class="comment">		2.malloc函数的使用</span></span><br><span class="line"><span class="comment">			（1）作用：分配一块连续的内存空间并返回所分配空间的起始地址</span></span><br><span class="line"><span class="comment">			（2）常用格式：L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);</span></span><br><span class="line"><span class="comment">			（3）注意：使用该函数一般要判断其返回值，若返回值为NULL，则说明分配失败，程序要进行相应处理</span></span><br><span class="line"><span class="comment">		3.free（）函数</span></span><br><span class="line"><span class="comment">			 (1)释放内存空间</span></span><br><span class="line"><span class="comment">			 (2)与malloc函数是一对,malloc返回值为内存空间基址，free参数为内存空间基址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SeqList</span> &#123;</span><br><span class="line">	ElemType* data;		<span class="comment">//指示动态分配数组的指针，也就是malloc函数返回的分配空间的起始地址</span></span><br><span class="line">	<span class="type">int</span> MaxSize;		<span class="comment">//顺序表的最大容量</span></span><br><span class="line">	<span class="type">int</span> length;			<span class="comment">//顺序表当前长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SeqList&amp; L)</span> </span>&#123;</span><br><span class="line">	L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType) * InitSize);</span><br><span class="line">	L.MaxSize = InitSize;</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;顺序表初始化成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.求表长：返回顺序表的长度，即L中数据元素的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">(SeqList L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.判空：判断顺序表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(SeqList L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;顺序表为空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;顺序表非空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.增加动态数组的长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList&amp; L, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = L.data;</span><br><span class="line">	L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType) * (L.MaxSize + len));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)		<span class="comment">//将数据复制到新区域(时间开销大)</span></span><br><span class="line">		L.data[i] = p[i];</span><br><span class="line">	L.MaxSize += len;			<span class="comment">//顺序表的最大长度增加len</span></span><br><span class="line">	<span class="built_in">free</span>(p);		<span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.插入操作：在表L的位序i上插入指定元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertList</span><span class="params">(SeqList&amp; L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length + <span class="number">1</span>)		<span class="comment">//判断要插入的位序i是否合法（合法范围[1,length+1]，即首部和尾部之间）</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (L.length &gt;= L.MaxSize)		<span class="comment">//判断当前存储空间是否已满，若已满，不能插入</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; j--)		<span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">		L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">	L.data[i - <span class="number">1</span>] = e;					<span class="comment">//位序为i处放入指定元素e</span></span><br><span class="line">	L.length++;						<span class="comment">//顺序表长度+1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.删除操作：删除表中位序为i的元素，并用e返回删除元素的值</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SeqList&amp; L, <span class="type">int</span> i, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length) &#123;	<span class="comment">//判断要删除的位序是否合法(合法范围为[1,length])</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	e = L.data[i - <span class="number">1</span>];				<span class="comment">//位序i的元素赋给e</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; L.length; j++)		<span class="comment">//将第i个元素之后的元素前移</span></span><br><span class="line">		L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">	L.length--;					<span class="comment">//顺序表长度-1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7-1.查找操作-按位查找：获取表L中位序为i的元素的值</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SeqList L, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7-2.查找操作-按值查找：查找表L中第一个元素值为e的元素，并返回其位序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SeqList L, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">		<span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line">			<span class="keyword">return</span> i + <span class="number">1</span>;		<span class="comment">//数组下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//返回值为0，说明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.遍历顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(SeqList L)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历开始：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        cout&lt;&lt;L.data[i]&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,i;</span><br><span class="line">	ElemType a,e=<span class="number">-1</span>;		</span><br><span class="line">	SeqList L;		<span class="comment">//声明一个顺序表</span></span><br><span class="line">	<span class="built_in">InitList</span>(L);	<span class="comment">//初始化顺序表</span></span><br><span class="line">	<span class="comment">/*0、判空*/</span></span><br><span class="line">	<span class="built_in">Empty</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*1、插入元素*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入元素个数：&quot;</span>;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;		</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">InsertList</span>(L, i + <span class="number">1</span>, a))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;成功插入第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;个元素：&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;个元素插入失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*2、判空*/</span>		</span><br><span class="line">	<span class="built_in">Empty</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*3、遍历当前顺序表*/</span></span><br><span class="line">	<span class="built_in">PrintList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*4、删除元素*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入您要删除元素的位序i：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;i;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ListDelete</span>(L, i, e))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;已删除第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素，其值为：&quot;</span>&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;位序i不合法,删除失败！&quot;</span>&lt;&lt;endl;        </span><br><span class="line"></span><br><span class="line">	<span class="comment">/*5、输出当前表长*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;当前表长为：&quot;</span>&lt;&lt;<span class="built_in">Length</span>(L)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*6、遍历当前顺序表*/</span></span><br><span class="line">	<span class="built_in">PrintList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*7、按位查找*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入您要查找元素的位序i：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;i;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetElem</span>(L, i) == <span class="number">-1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;您输入的位序不合法！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;位序为&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;的值为：&quot;</span>&lt;&lt;<span class="built_in">GetElem</span>(L, i)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*8、按值查找*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入您要查找元素的值：&quot;</span>;</span><br><span class="line">	cin&gt;&gt;a;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;值为&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;的元素第一次出现的位序为&quot;</span>&lt;&lt;<span class="built_in">LocateElem</span>(L, a)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" yellow><summary> 例题 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 题目一 </summary>              <div class='content'>              <blockquote><p>假设顺序表非空。从顺序表中找出最小值，及其下标。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">findMin</span><span class="params">(SqList &amp;L, <span class="type">int</span> &amp;value,<span class="type">int</span> &amp;pos)</span></span>&#123;</span><br><span class="line">    value=L.data[<span class="number">0</span>];</span><br><span class="line">    pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]&lt;value)&#123;</span><br><span class="line">            value=L.data[i];</span><br><span class="line">            pos=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        cout&lt;&lt;L.data[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    L.length=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;表L:&quot;</span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="built_in">findMin</span>(L,pos,value);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;最小值为：&quot;</span>&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;位序为：&quot;</span>&lt;&lt;pos&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>              </div>            </details><details class="folding-tag" blue><summary> 题目二 </summary>              <div class='content'>              <blockquote><p>从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> *data;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">	<span class="type">int</span> MaxSize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">	L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	L.length=<span class="number">0</span>;</span><br><span class="line">	L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findmin</span><span class="params">(SqList &amp;L,<span class="type">int</span> &amp;value,<span class="type">int</span> &amp;pos)</span></span>&#123;</span><br><span class="line">	value=L.data[<span class="number">0</span>];</span><br><span class="line">	pos=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(L.data[i]&lt;value)&#123;</span><br><span class="line">			value=L.data[i];</span><br><span class="line">			pos=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deleteList</span><span class="params">(SqList &amp;L,<span class="type">int</span> &amp;value)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> pos;</span><br><span class="line">	<span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">findmin</span>(L,value,pos);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> end=L.length<span class="number">-1</span>;</span><br><span class="line">	L.data[pos]=L.data[end];</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SqList L;</span><br><span class="line">	<span class="built_in">InitList</span>(L);</span><br><span class="line">	cin&gt;&gt;L.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">		cin&gt;&gt;L.data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="built_in">deleteList</span>(L,a);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">		cout&lt;&lt;L.data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>              </div>            </details><details class="folding-tag" blue><summary> 题目三 </summary>              <div class='content'>              <blockquote><p>设计一个高效算法，将顺序表L的所有元素逆置，要求算法的时间复杂度为O(1).<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp=L.data[i];</span><br><span class="line">        L.data[i]=L.data[L.length-i<span class="number">-1</span>];</span><br><span class="line">        L.data[L.length-i<span class="number">-1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        cout&lt;&lt;L.data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    cin&gt;&gt;L.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Reverse</span>(L);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>              </div>            </details><details class="folding-tag" blue><summary> 题目四 </summary>              <div class='content'>              <blockquote><p>在顺序表L的第i(i&lt;=L.length+1)个位置插入新元素e。若i的输入不合法，则返回false，表示插入失败；否则，将第i个元素及其后的所有元素依次往后移动一个位置，腾出一个kon位置插入新元素e，顺序表长度增加1，插入成功，返回true.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> &amp;pos,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;L.length+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=L.length;i&gt;=pos;i--)&#123;</span><br><span class="line">            L.data[i+<span class="number">1</span>]=L.data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[pos]=e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;L.data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    cin&gt;&gt;L.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> e,pos;</span><br><span class="line">    cin&gt;&gt;pos&gt;&gt;e;</span><br><span class="line">    <span class="built_in">ListInsert</span>(L,pos,e);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>              </div>            </details><details class="folding-tag" blue><summary> 题目五 </summary>              <div class='content'>              <blockquote><p>对长度为n的顺序表L，编写一个时间复杂度为O(n),空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//解法一</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> MAxSize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MAxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteList</span><span class="params">(SqList &amp;L,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]!=value)&#123;</span><br><span class="line">            L.data[j]=L.data[i];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length=j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        cout&lt;&lt;L.data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    cin&gt;&gt;L.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="built_in">deleteList</span>(L,x);</span><br><span class="line">    <span class="built_in">printList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解法二</span></span><br><span class="line"><span class="comment">// #include&lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define InitSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct&#123;</span></span><br><span class="line"><span class="comment">//     int *data;</span></span><br><span class="line"><span class="comment">//     int length;</span></span><br><span class="line"><span class="comment">//     int MAxSize;</span></span><br><span class="line"><span class="comment">// &#125;SqList;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void InitList(SqList &amp;L)&#123;</span></span><br><span class="line"><span class="comment">//     L.data=(int *)malloc(InitSize*sizeof(int));</span></span><br><span class="line"><span class="comment">//     L.length=0;</span></span><br><span class="line"><span class="comment">//     L.MAxSize=InitSize;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void deleteList(SqList &amp;L,int x)&#123;</span></span><br><span class="line"><span class="comment">//     int k=0;</span></span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;L.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//         if(L.data[i]==x)</span></span><br><span class="line"><span class="comment">//         k++;</span></span><br><span class="line"><span class="comment">//         else</span></span><br><span class="line"><span class="comment">//         L.data[i-k]=L.data[i];</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     L.length=L.length-k;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void printList(SqList &amp;L)&#123;</span></span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;L.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//         cout&lt;&lt;L.data[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()&#123;</span></span><br><span class="line"><span class="comment">//     SqList L;</span></span><br><span class="line"><span class="comment">//     InitList(L);</span></span><br><span class="line"><span class="comment">//     cin&gt;&gt;L.length;</span></span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;L.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//         cin&gt;&gt;L.data[i];</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     int x;</span></span><br><span class="line"><span class="comment">//     cin&gt;&gt;x;</span></span><br><span class="line"><span class="comment">//     deleteList(L,x);</span></span><br><span class="line"><span class="comment">//     printList(L);</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p></blockquote>              </div>            </details><details class="folding-tag" blue><summary> 题目六 </summary>              <div class='content'>              <blockquote><p>从顺序表中删除其值在给定值s与t之间(包含s和t，要求s<t)的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deleteList</span><span class="params">(SqList &amp;L,<span class="type">int</span> &amp;s,<span class="type">int</span> &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span>||s&gt;=t)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L.data[i]&lt;s||L.data[i]&gt;t)&#123;</span><br><span class="line">                L.data[j]=L.data[i];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        L.length=j;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        cout&lt;&lt;L.data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    cin&gt;&gt;L.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s,t;</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="built_in">deleteList</span>(L,s,t);</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>              </div>            </details><details class="folding-tag" blue><summary> 题目七 </summary>              <div class='content'>              <blockquote><p>从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void DeleteList(SqList &amp;L)&#123;</span></span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;L.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//         if(L.data[i]==L.data[i+1])&#123;</span></span><br><span class="line"><span class="comment">//             for(int j=i+1;j&lt;L.length;j++)&#123;</span></span><br><span class="line"><span class="comment">//                 L.data[j]=L.data[j+1];</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             L.length--;</span></span><br><span class="line"><span class="comment">//             DeleteList(L);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]==L.data[i-k<span class="number">-1</span>])&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;i:&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;k:&quot;</span>&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;L.data[i]&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;L.data[i-k<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;i-k<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        k++;&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        L.data[i-k]=L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length=L.length-k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        cout&lt;&lt;L.data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    cin&gt;&gt;L.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        cin&gt;&gt;L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DeleteList</span>(L);</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>              </div>            </details>              </div>            </details>
              </div>
            </details>
<h1 id="链表-LinkList"><a href="#链表-LinkList" class="headerlink" title="链表-LinkList"></a>链表-LinkList</h1><details class="folding-tag" yellow><summary> 链表 </summary>
              <div class='content'>
              <details class="folding-tag" blue><summary> 头插法建立单链表 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法建立单链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">InitListByHead</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=s;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintLinkList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="built_in">InitListByHead</span>(L);</span><br><span class="line">    <span class="built_in">PrintLinkList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 尾插法建立单链表 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法建立单链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">InitListByHead</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=r-&gt;next;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintLinkList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    L=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="built_in">InitListByHead</span>(L);</span><br><span class="line">    <span class="built_in">PrintLinkList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 单链表的按位查找 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">InitListByHead</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=r-&gt;next;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LNode *<span class="title">getElemByPos</span><span class="params">(LinkList L,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintLinkList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    L=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;L-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="built_in">InitListByHead</span>(L);</span><br><span class="line">    <span class="built_in">PrintLinkList</span>(L);</span><br><span class="line">    <span class="built_in">getElemByPos</span>(L,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 单链表的按值查找 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的按值查找</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">InitListByHead</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=r-&gt;next;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElemByValue</span><span class="params">(LinkList L,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> p;                               </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="built_in">InitListByHead</span>(L);</span><br><span class="line">    <span class="built_in">LocateElemByValue</span>(L,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 求单链表的表长 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求单链表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">InitListByHead</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=r-&gt;next;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="built_in">InitListByHead</span>(L);</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">length</span>(L);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;单链表的长度为：&quot;</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 单链表的插入操作-尾插法 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">InitListByHead</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=r-&gt;next;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;<span class="built_in">length</span>(L)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s;</span><br><span class="line">    s=(LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;pos&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        pos++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pos:&quot;</span>&lt;&lt;pos&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p:&quot;</span>&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="built_in">InitListByHead</span>(L);</span><br><span class="line">    <span class="built_in">ListInsert</span>(L,<span class="number">3</span>,<span class="number">99</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 单链表的插入操作-头插法 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法建立单链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">InitListByLater</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=r-&gt;next;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找第i个元素</span></span><br><span class="line"><span class="function">LNode *<span class="title">getElemByPos</span><span class="params">(LinkList L,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;i:&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求单链表的表长</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表的按位序插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;<span class="built_in">length</span>(L)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    LNode *s=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line"></span><br><span class="line">    LNode *p=<span class="built_in">getElemByPos</span>(L,i<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p:&quot;</span>&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="built_in">InitListByLater</span>(L);</span><br><span class="line">    <span class="type">int</span> i,e;</span><br><span class="line">    cin&gt;&gt;i&gt;&gt;e;</span><br><span class="line">    <span class="built_in">ListInsert</span>(L,i,e);</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 单链表的删除操作 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">InitListByHead</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=r-&gt;next;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LNode *<span class="title">getElemLocate</span><span class="params">(LinkList L,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        LNode *p=L-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteElem</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;<span class="built_in">length</span>(L)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p=<span class="built_in">getElemLocate</span>(L,i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q=p-&gt;next;</span><br><span class="line">    e=q-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="built_in">InitListByHead</span>(L);</span><br><span class="line">    <span class="type">int</span> i,e,x;</span><br><span class="line">    cin&gt;&gt;i;</span><br><span class="line">    <span class="built_in">DeleteElem</span>(L,i,e);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;e:&quot;</span>&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 单链表删除指定节点 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">InitListByHead</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=r-&gt;next;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LNode *<span class="title">getElemLocate</span><span class="params">(LinkList L,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        LNode *p=L-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteElem</span><span class="params">(LinkList &amp;L,LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q=p-&gt;next;</span><br><span class="line">    p-&gt;data=p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="built_in">InitListByHead</span>(L);</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="built_in">DeleteElem</span>(L,p);</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 双链表的基本操作(全集) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// DLinkList InitDLinkList(DLinkList&amp; L);					//1.初始化双链表</span></span><br><span class="line"><span class="comment">// bool Empty(DLinkList L);								//2.判空</span></span><br><span class="line"><span class="comment">// DNode* GetElem(DLinkList L, int i);						//3-1.查找操作-按位查找</span></span><br><span class="line"><span class="comment">// DNode* LocateElem(DLinkList L, ElemType e);				//3-2.查找操作-按值查找</span></span><br><span class="line"><span class="comment">// bool InsertNextDNode1(DNode* p, DNode* s);				//4-1-1.插入操作-指定结点后插1-给结点</span></span><br><span class="line"><span class="comment">// bool InsertNextDNode2(DNode* p, ElemType e);			//4-1-2.插入操作-指定结点后插2-给元素值</span></span><br><span class="line"><span class="comment">// bool InsertPriorDNode(DNode* p, DNode* s);				//4-2.插入操作-指定结点前插</span></span><br><span class="line"><span class="comment">// bool InsertDLinkList(DLinkList&amp; L, int i, ElemType e);	//4-3.插入操作-按位插入</span></span><br><span class="line"><span class="comment">// bool DeleteNextDNode(DNode* p);							//5.删除操作-删除指定结点p的后继结点q</span></span><br><span class="line"><span class="comment">// DLinkList List_HeadInsert(DLinkList&amp; L);				//6.创建双链表：头插法</span></span><br><span class="line"><span class="comment">// void DestoryList(DLinkList&amp; L);							//7.销毁操作</span></span><br><span class="line"><span class="comment">// int Length(DLinkList L);								//8.求表长</span></span><br><span class="line"><span class="comment">// void PrintDLinkList(DLinkList L);						//9.遍历</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior,*next;</span><br><span class="line">&#125;DNode,*DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化双链表(带头结点)</span></span><br><span class="line"><span class="function">DLinkList <span class="title">InitDLinkList</span><span class="params">(DLinkList&amp; L)</span> </span>&#123;</span><br><span class="line">	L = (DNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));		<span class="comment">//创建头结点</span></span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//内存不足，分配失败</span></span><br><span class="line">	L-&gt;prior = <span class="literal">NULL</span>;	<span class="comment">//头结点的prior永远指向NULL，可作判断逆向遍历的条件</span></span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;		<span class="comment">//头结点之后暂时没有结点</span></span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (L-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3-1.查找操作-按位查找：返回第i个结点</span></span><br><span class="line"><span class="function">DNode* <span class="title">GetElem</span><span class="params">(DLinkList L, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	DNode* p = L;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;		<span class="comment">//也可能返回NULL，当输入i大于双链表长度时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3-2.查找操作-按值查找：找到第一个数据域为e的结点</span></span><br><span class="line"><span class="function">DNode* <span class="title">LocateElem</span><span class="params">(DLinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">	DNode* p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;data != e) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-1-1.插入操作-指定结点后插1-给结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode1</span><span class="params">(DNode* p, DNode* s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)		<span class="comment">//非法参数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	DNode* q = p-&gt;next;</span><br><span class="line">	s-&gt;next = q;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)	<span class="comment">//判断p是不是最后一个结点</span></span><br><span class="line">		q-&gt;prior = s;		<span class="comment">//如果是，则跳过此句，因为p的后继为NULL，没有前驱</span></span><br><span class="line">	s-&gt;prior = p;</span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-1-2.插入操作-指定结点后插2-给元素值</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode2</span><span class="params">(DNode* p, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)		<span class="comment">//非法参数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	DNode* q = p-&gt;next;		<span class="comment">//q为p原先的后继结点</span></span><br><span class="line">	DNode* s = (DNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));	<span class="comment">//s为p新的后继结点</span></span><br><span class="line">	<span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//内存不足，分配失败</span></span><br><span class="line">	s-&gt;data = e;	<span class="comment">//为新结点赋值</span></span><br><span class="line">	s-&gt;next = q;</span><br><span class="line">	<span class="keyword">if</span>(q!=<span class="literal">NULL</span>)			<span class="comment">//判断q是不是最后一个结点</span></span><br><span class="line">		q-&gt;prior = s;		<span class="comment">//如果是，则跳过此句，因为q为NULL，没有前驱</span></span><br><span class="line">	s-&gt;prior = p;</span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-2.插入操作-指定结点前插</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertPriorDNode</span><span class="params">(DNode* p, DNode* s)</span> </span>&#123;</span><br><span class="line">	DNode* q = p-&gt;prior;	<span class="comment">//先找到p的前驱结点q</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">InsertNextDNode1</span>(q, s);	<span class="comment">//对q进行后插操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-3.插入操作-按位插入</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertDLinkList</span><span class="params">(DLinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	DNode* p = <span class="built_in">GetElem</span>(L, i<span class="number">-1</span>);		<span class="comment">//按位查找i-1个结点p</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">InsertNextDNode2</span>(p, e);	<span class="comment">//对p结点进行后插操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.删除操作-删除指定结点p的后继结点q</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode* p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//非法参数：p不存在</span></span><br><span class="line">	DNode* q = p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (q == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//p没有后继结点</span></span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;next != <span class="literal">NULL</span>)				<span class="comment">//判断q是不是最后一个结点</span></span><br><span class="line">		q-&gt;next-&gt;prior = p;		<span class="comment">//如果是，则跳过此句，因为q-&gt;next为NULL，没有前驱</span></span><br><span class="line">	<span class="built_in">free</span>(q);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.创建双链表：头插法（创建方法与单链表相同，其他方法不再声明，仅用头插法测试）</span></span><br><span class="line"><span class="function">DLinkList <span class="title">List_HeadInsert</span><span class="params">(DLinkList&amp; L)</span> </span>&#123;</span><br><span class="line">	L = <span class="built_in">InitDLinkList</span>(L);		<span class="comment">//初始化双链表</span></span><br><span class="line">	ElemType x;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;		<span class="comment">//用作记录插入第几个元素</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;开始创建双链表！&quot;</span>&lt;&lt;endl&lt;&lt;<span class="string">&quot;请输入&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">InsertNextDNode2</span>(L, x)) 		<span class="comment">//头插法本质是头结点的后插操作</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;成功插入第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素：&quot;</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;插入第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入&quot;</span>&lt;&lt;++i&lt;&lt;<span class="string">&quot;个元素&quot;</span>&lt;&lt;endl;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">	&#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;双链表创建完成&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.销毁操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryList</span><span class="params">(DLinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;开始销毁双链表！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//循环释放各个数据结点--对头结点依次做删除操作</span></span><br><span class="line">	<span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>) </span><br><span class="line">		<span class="built_in">DeleteNextDNode</span>(L);</span><br><span class="line">	<span class="built_in">free</span>(L);	<span class="comment">//释放头结点</span></span><br><span class="line">	L = <span class="literal">NULL</span>;	<span class="comment">//头指针指向NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.求表长</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	DNode* p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDLinkList</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">	DNode* p = L-&gt;next;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历双链表：&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DLinkList L;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    L=<span class="built_in">List_HeadInsert</span>(L);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;当前表长为:&quot;</span>&lt;&lt;<span class="built_in">Length</span>(L);</span><br><span class="line">    <span class="built_in">PrintDLinkList</span>(L);</span><br><span class="line"></span><br><span class="line">    ElemType e1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入您所要插入的位序i和元素值e:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;i&gt;&gt;e1;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">InsertDLinkList</span>(L,i,e1))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;您已成功插入元素值：&quot;</span>&lt;&lt;e1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;位序i不合法，插入元素值&quot;</span>&lt;&lt;e1&lt;&lt;<span class="string">&quot;失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PrintDLinkList</span>(L);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入您要查找的位序i：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;i;</span><br><span class="line">    DNode *p1=<span class="built_in">GetElem</span>(L,i);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;位序为&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;的值为:&quot;</span>&lt;&lt;p1-&gt;data&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入您要查找的元素值e：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;e2;</span><br><span class="line">    DNode *p2=<span class="built_in">LocateElem</span>(L,e2);</span><br><span class="line"></span><br><span class="line">    DNode *p3=(DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">    p3-&gt;data=p2-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">InsertPriorDNode</span>(p1,p3))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;前插成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">DeleteNextDNode</span>(p2-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;前插失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintDLinkList</span>(L);</span><br><span class="line"></span><br><span class="line">    ElemType e3=p1-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">DeleteNextDNode</span>(p1))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;此结点后继结点删除成功,值为:&quot;</span>&lt;&lt;e3&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;此结点后继结点删除失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PrintDLinkList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DestoryList</span>(L);</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;双链表已销毁!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;双链表销毁失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 单链表的基本操作（全集） </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /*函数声明*/</span></span><br><span class="line"><span class="comment">// bool InitList(LinkList&amp; L);						//1.初始化循环单链表</span></span><br><span class="line"><span class="comment">// bool Empty(LinkList L);							//2.判空</span></span><br><span class="line"><span class="comment">// bool isTail(LinkList L, LNode* p);				//3.判断表尾结点</span></span><br><span class="line"><span class="comment">// LNode* GetElem(LinkList L, int i);				//4.按位查找</span></span><br><span class="line"><span class="comment">// bool InsertNextNode(LNode* p, ElemType e);		//5.指定结点后插</span></span><br><span class="line"><span class="comment">// LinkList List_HeadInsert(LinkList&amp; L);			//6.头插法</span></span><br><span class="line"><span class="comment">// void PrintList(LinkList L);						//7.遍历</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bool InitList(LinkList&amp; L);						//1.初始化循环单链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                 <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next=L;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;            <span class="comment">//初始化成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bool Empty(LinkList L);							//2.判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next!=L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bool isTail(LinkList L, LNode* p);				//3.判断表尾结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTail</span><span class="params">(LinkList L,LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LNode* GetElem(LinkList L, int i);				//4.按位查找</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)                                         <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p=L;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bool InsertNextNode(LNode* p, ElemType e);		//5.指定结点后插</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkList List_HeadInsert(LinkList&amp; L);			//6.头插法</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">InitList</span>(L))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;创建循环单链表成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;创建循环单链表失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Empty</span>(L))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前单链表为空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前单链表非空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ElemType x;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;开始创建循环单链表！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">InsertNextNode</span>(L,x))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;成功插入第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素:&quot;</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;插入第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;创建循环单链表完成！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void PrintList(LinkList L);						//7.遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=L)&#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    L=<span class="built_in">List_HeadInsert</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Empty</span>(L))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前表为空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前表非空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按位查找</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入要查找的位序i：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;i;</span><br><span class="line">    LNode *p=<span class="built_in">GetElem</span>(L,i);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;位序为&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;的值为：&quot;</span>&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断表尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isTail</span>(L,p))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前结点为表尾结点！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前结点非表尾结点！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定结点后插，以按位查找的p结点为例</span></span><br><span class="line">    ElemType e;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入您要后插的值：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;e;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">InsertNextNode</span>(p,e))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p结点后插成功！元素值为：&quot;</span>&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p结点后插失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再次判断表尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isTail</span>(L,p))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前结点为表尾结点！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前结点非表尾结点！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 循环双链表的基本操作(全集) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// bool InitDLinkList(DLinkList&amp; L);				//1.初始化循环双链表</span></span><br><span class="line"><span class="comment">// bool Empty(DLinkList L);						//2.判空</span></span><br><span class="line"><span class="comment">// bool isTail(DLinkList L, DNode* p);				//3.判断表尾结点</span></span><br><span class="line"><span class="comment">// DNode* GetElem(DLinkList L, int i);				//4.按位查找</span></span><br><span class="line"><span class="comment">// bool InsertNextDNode(DNode* p, ElemType e);		//5.指定结点后插</span></span><br><span class="line"><span class="comment">// bool DeleteNextDNode(DNode* p);					//6.删除指定结点的后继结点</span></span><br><span class="line"><span class="comment">// DLinkList List_HeadInsert(DLinkList&amp; L);		//7.头插法</span></span><br><span class="line"><span class="comment">// void PrintDLinkList(DLinkList L);				//8.遍历</span></span><br><span class="line"><span class="comment">// void DestoryList(DLinkList&amp; L);					//9.销毁循环双链表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior,*next;</span><br><span class="line">&#125;DNode ,*DLinkList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DLinkList <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L=(DLinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next=L;</span><br><span class="line">    L-&gt;prior=L;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bool isTail(DLinkList L, DNode* p);				//3.判断表尾结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTail</span><span class="params">(DLinkList L,DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找操作--按位查找</span></span><br><span class="line"><span class="function">DNode *<span class="title">GetElem</span><span class="params">(DLinkList L,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    DNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)&#123;</span><br><span class="line">        j++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function">DNode *<span class="title">LocateElem</span><span class="params">(DLinkList L,ElemType e)</span></span>&#123;</span><br><span class="line">    DNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;data!=e)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作，指定结点后插</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsetrNextDNode1</span><span class="params">(DNode *p,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)   <span class="comment">//非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *s=(DNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)   <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    p-&gt;next-&gt;prior=s;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    s-&gt;prior=p;    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作，删除指定结点p的后继结点q</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历双链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDLinkList</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    DNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=L)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryList</span><span class="params">(DLinkList&amp; L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next!=L)&#123;</span><br><span class="line">        <span class="built_in">DeleteNextDNode</span>(L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建循环链表--头插法</span></span><br><span class="line"><span class="function">DLinkList <span class="title">List_HeadInsert</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">InitDLinkList</span>(L))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;循环双链表初始化成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;循环双链表初始化失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Empty</span>(L))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;双链表非空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;双链表为空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ElemType e1;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;开始创建循环双链表！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;e1;</span><br><span class="line">    <span class="keyword">while</span>(e1!=<span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">InsetrNextDNode1</span>(L,e1))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;成功插入第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素：&quot;</span>&lt;&lt;e1&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;插入第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;++i&lt;&lt;<span class="string">&quot;个元素的值&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;e1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;循环双链表创建完成!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	DLinkList L;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*以下操作只要涉及对循环双链表的改动，均遍历循环双链表*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*1、头插法建立循环双链表*/</span></span><br><span class="line">	L = <span class="built_in">List_HeadInsert</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*2、判空*/</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Empty</span>(L))</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;当前双链表为空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;当前双联表非空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">PrintDLinkList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*3、按位查找*/</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;请输入要查找的位序：&quot;</span>;</span><br><span class="line">	cin&gt;&gt;i;</span><br><span class="line">	DNode* p = <span class="built_in">GetElem</span>(L, i);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;位序为&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;的值为：&quot;</span>&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">	<span class="comment">/*4.判断表尾结点*/</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isTail</span>(L, p))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前结点为表尾结点！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前结点不是表尾结点！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//*5、指定结点后插,以按位查找的p结点为例*/</span></span><br><span class="line">	ElemType e;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入您要后插的值：&quot;</span>;</span><br><span class="line">	cin&gt;&gt;e;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">InsetrNextDNode1</span>(p, e))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p结点后插成功，元素值为：&quot;</span>&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p结点后插失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">PrintDLinkList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*6.再次判断表尾结点*/</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isTail</span>(L, p))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前结点为表尾结点！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前结点不是表尾结点！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*7、删除指定结点的后继结点，此处删除p的后继结点*/</span></span><br><span class="line">	ElemType e1 = p-&gt;next-&gt;data;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">DeleteNextDNode</span>(p))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;此结点后继结点删除成功，值为：&quot;</span>&lt;&lt;e1&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;此结点后继结点删除失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">PrintDLinkList</span>(L);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*8、销毁循环双链表*/</span></span><br><span class="line">	<span class="built_in">DestoryList</span>(L);</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;循环双链表已销毁!&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;循环双链表销毁失败哦！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 静态链表 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testLinkLis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> x;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeX=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(x)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> a[MaxSize];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeA=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;</span><br><span class="line">    SLinkList b;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeB=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(b)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">testLinkLis</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details>
              </div>
            </details>
<h1 id="栈和队列-Stack-amp-amp-Queue"><a href="#栈和队列-Stack-amp-amp-Queue" class="headerlink" title="栈和队列-Stack &amp;&amp; Queue"></a>栈和队列-Stack &amp;&amp; Queue</h1><details class="folding-tag" yellow><summary> 栈和队列 </summary>
              <div class='content'>
              <details class="folding-tag" pink><summary> 栈 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 顺序栈的基本操作（初始化栈顶指针为-1） </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitStack(SqStack &amp;S);				    //1.初始化顺序栈</span></span><br><span class="line"><span class="comment">// bool StackEmpty(SqStack S);				    //2.判空</span></span><br><span class="line"><span class="comment">// bool Push(SqStack &amp;S,ElemType x);		    //3.入栈</span></span><br><span class="line"><span class="comment">// bool Pop(SqStack &amp;S,ElemType &amp;x);			//4.出栈</span></span><br><span class="line"><span class="comment">// bool GetTop(SqStack S,ElemType &amp;x);		    //5.读取栈顶元素</span></span><br><span class="line"><span class="comment">// PrintSqStack(SqStack S);                     //6.遍历栈内元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[S.top]=x;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s.top:&quot;</span>&lt;&lt;S.top&lt;&lt;endl;</span><br><span class="line">    S.top++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    S.top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSqStack</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历栈：&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(S.top!=<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;S.top:&quot;</span>&lt;&lt;S.top&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;S.data[S.top]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;</span><br><span class="line">        S.top--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前栈空&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前栈非空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ElemType e1;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;请输入入栈元素的值：&quot;;</span></span><br><span class="line">    <span class="comment">// cin&gt;&gt;e1;</span></span><br><span class="line">    <span class="comment">// if(Push(S,e1))</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;&quot;新元素入栈成功！&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// else</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;&quot;新元素入栈失败！&quot;&lt;&lt;endl; </span></span><br><span class="line"></span><br><span class="line">    ElemType e1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入入栈元素的值：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;e1;</span><br><span class="line">    <span class="keyword">while</span>(e1!=<span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Push</span>(S,e1))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;新元素入栈成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;新元素入栈失败！&quot;</span>&lt;&lt;endl; </span><br><span class="line">        cin&gt;&gt;e1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintSqStack</span>(S);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ElemType e2=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetTop</span>(S,e2))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;读取栈顶元素成功，当前栈顶元素值为:&quot;</span>&lt;&lt;e2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈已空，读取栈顶元素失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e3=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Pop</span>(S,e3))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈顶元素出栈成功，出栈元素值为：&quot;</span>&lt;&lt;e3&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈已空，栈顶元素出栈失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    ElemType e4=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetTop</span>(S,e3))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;读取栈顶元素成功，当前栈顶元素值为:&quot;</span>&lt;&lt;e2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈已空，读取栈顶元素失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 顺序栈的基本操作（初始化栈顶指针为0） </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitStack(SeqStack&amp; S);				//1.初始化顺序栈</span></span><br><span class="line"><span class="comment">// bool StackEmpty(SeqStack S);				//2.判空</span></span><br><span class="line"><span class="comment">// bool Push(SeqStack&amp; S, ElemType x);			//3.入栈</span></span><br><span class="line"><span class="comment">// bool Pop(SeqStack&amp; S, ElemType&amp; x);			//4.出栈</span></span><br><span class="line"><span class="comment">// bool GetTop(SeqStack S, ElemType&amp; x);		//5.读取栈顶元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitSqStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[S.top]=e;</span><br><span class="line">    S.top++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top=S.top<span class="number">-1</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[--S.top];</span><br><span class="line">    S.top++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSqStack</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历栈:&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(S.top!=<span class="number">0</span>)&#123;</span><br><span class="line">        S.top--;</span><br><span class="line">        cout&lt;&lt;S.data[S.top]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">InitSqStack</span>(S);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前栈为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前栈非空！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入入栈元素的值：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;e1;</span><br><span class="line">    <span class="keyword">while</span>(e1!=<span class="number">9999</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Push</span>(S,e1))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;新元素入栈成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;新元素入栈失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;e1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ElemType e2=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Pop</span>(S,e2))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈顶元素出栈成功！值为：&quot;</span>&lt;&lt;e2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈顶元素出栈失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    ElemType e3=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetTop</span>(S,e3))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;成功获取栈顶元素，值为：&quot;</span>&lt;&lt;e3&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;获取栈顶元素失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">PrintSqStack</span>(S);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 共享栈的基础操作 (初始化栈1栈顶指针为-1，栈2栈顶指针为MaxSize) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitSqStack(SqStack&amp; S);				//1.初始化共享栈</span></span><br><span class="line"><span class="comment">// bool Stack1Empty(SqStack S);				//2. 1号栈判空</span></span><br><span class="line"><span class="comment">// bool Stack2Empty(SqStack S);				//2. 2号栈判空</span></span><br><span class="line"><span class="comment">// bool Push1(SqStack&amp; S, ElemType x);			//3. 1号栈入栈</span></span><br><span class="line"><span class="comment">// bool Push2(SqStack&amp; S, ElemType x);			//4. 2号栈入栈</span></span><br><span class="line"><span class="comment">// bool Pop1(SqStack&amp; S, ElemType&amp; x);			//5. 1号栈出栈</span></span><br><span class="line"><span class="comment">// bool Pop2(SqStack&amp; S, ElemType&amp; x);			//6. 2号栈出栈</span></span><br><span class="line"><span class="comment">// bool GetTop1(SqStack S, ElemType&amp; x);		//7. 1号栈读取栈顶元素</span></span><br><span class="line"><span class="comment">// bool GetTop2(SqStack S, ElemType&amp; x);		//8. 2号栈读取栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top1;</span><br><span class="line">    <span class="type">int</span> top2;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitSqStack</span><span class="params">(SqStack&amp; S)</span></span>&#123;                <span class="comment">//1.初始化共享栈</span></span><br><span class="line">    S.top1=<span class="number">-1</span>;</span><br><span class="line">    S.top2=MaxSize;</span><br><span class="line">&#125;				</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack1Empty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top1==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;			</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack2Empty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top2==MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push1</span><span class="params">(SqStack&amp; S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top1+<span class="number">1</span>==S.top2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top1++;</span><br><span class="line">    S.data[S.top1]=x;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;S.top:&quot;</span>&lt;&lt;S.top1&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push2</span><span class="params">(SqStack&amp; S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top1+<span class="number">1</span>==S.top2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top2--;            <span class="comment">//数组长度为MaxSize，但是数组下标最大为（MaxSize-1）</span></span><br><span class="line">    S.data[S.top2]=x;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;S.top2：&quot;</span>&lt;&lt;S.top2&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop1</span><span class="params">(SqStack&amp; S, ElemType&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top1==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top1];</span><br><span class="line">    S.top1--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop2</span><span class="params">(SqStack&amp; S, ElemType&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top2==MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top2];</span><br><span class="line">    S.top2++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop1</span><span class="params">(SqStack S, ElemType&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top1==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top1++];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop2</span><span class="params">(SqStack S, ElemType&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top2==MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top2--];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStack1</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top1==<span class="number">-1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;共享栈1为空!!!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历共享栈1：&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(S.top1!=<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;S.data[S.top1]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        S.top1--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStack2</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top2==MaxSize)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;共享栈2为空!!!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历共享栈1：&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(S.top2!=MaxSize)&#123;</span><br><span class="line">        cout&lt;&lt;S.data[S.top2]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        S.top2++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">InitSqStack</span>(S);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Stack1Empty</span>(S)&amp;&amp;<span class="built_in">Stack2Empty</span>(S))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前栈为空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前栈非空！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ElemType e1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;在共享栈1中插入元素：请输入要插入的值：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;e1;</span><br><span class="line">    <span class="keyword">while</span>(e1!=<span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Push1</span>(S,e1))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;共享栈1中插入成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;共享栈1插入元素失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;e1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ElemType e2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;在共享栈2中插入元素：请输入要插入的值：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;e2;</span><br><span class="line">    <span class="keyword">while</span>(e2!=<span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Push2</span>(S,e2))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;共享栈2中插入成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;共享栈2插入元素失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;e2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ElemType e3=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Pop1</span>(S,e3))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;共享栈1栈顶元素出栈成功：值为：&quot;</span>&lt;&lt;e3&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;共享栈1栈顶元素出栈失败!!!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e4=MaxSize;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Pop2</span>(S,e4))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;共享栈2栈顶元素出栈成功：值为：&quot;</span>&lt;&lt;e4&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;共享栈2栈顶元素出栈失败!!!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e5=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetTop1</span>(S,e5))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;成功获取栈顶元素！值为：&quot;</span>&lt;&lt;e5&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;获取栈顶元素失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e6=MaxSize;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetTop2</span>(S,e6))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;成功获取栈顶元素！值为：&quot;</span>&lt;&lt;e6&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;获取栈顶元素失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintStack1</span>(S);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintStack2</span>(S);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 链栈无头结点 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// bool InitLinkStack(LiStack&amp; S);			//1.初始化链栈</span></span><br><span class="line"><span class="comment">// bool LiStackEmpty(LiStack S);			//2.判空</span></span><br><span class="line"><span class="comment">// bool Push(LiStack&amp; S, ElemType e);		//3.入栈</span></span><br><span class="line"><span class="comment">// bool Pop(LiStack&amp; S, ElemType&amp; e);		//4.出栈</span></span><br><span class="line"><span class="comment">// bool GetTop(LiStack S, ElemType&amp; e);	//5.读取栈顶元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkStackNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkStackNode</span>* next;</span><br><span class="line">&#125;*LiStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitLinkStack</span><span class="params">(LiStack&amp; S)</span></span>&#123;</span><br><span class="line">    S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LiStackEmpty</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(S==<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LiStack&amp; S, ElemType e)</span></span>&#123;</span><br><span class="line">    LiStack p=(LiStack)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LiStack));</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=S;</span><br><span class="line">    S=p;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LiStack&amp; S, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//栈空，报错</span></span><br><span class="line">	LiStack p=S;</span><br><span class="line">	e = p-&gt;data;</span><br><span class="line">	S = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(LiStack S, ElemType&amp; e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e=S-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintfLiStack</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历链栈：&quot;</span>;</span><br><span class="line">    LiStack p=S;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LiStack S;</span><br><span class="line">    <span class="built_in">InitLinkStack</span>(S);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">LiStackEmpty</span>(S))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈为空！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈非空!!!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入插入的元素：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;e1;</span><br><span class="line">    <span class="keyword">while</span>(e1!=<span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Push</span>(S,e1))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;元素入栈成功！！！值为：&quot;</span>&lt;&lt;e1&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;元素入栈失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;e1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintfLiStack</span>(S);</span><br><span class="line"></span><br><span class="line">    ElemType e2=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Pop</span>(S,e2))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;返回栈顶元素值为：&quot;</span>&lt;&lt;e2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;返回栈顶元素值失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e3=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetTop</span>(S,e3))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;读取栈顶元素值成功！！！值为：&quot;</span>&lt;&lt;e3&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;读取栈顶元素值失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">PrintfLiStack</span>(S);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 链栈带头结点 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// bool InitLinkStack(LiStack&amp; S);			//1.初始化链栈</span></span><br><span class="line"><span class="comment">// bool LiStackEmpty(LiStack S);			//2.判空</span></span><br><span class="line"><span class="comment">// bool Push(LiStack&amp; S, ElemType e);		//3.入栈</span></span><br><span class="line"><span class="comment">// bool Pop(LiStack&amp; S, ElemType&amp; e);		//4.出栈</span></span><br><span class="line"><span class="comment">// bool GetTop(LiStack S, ElemType&amp; e);	//5.读取栈顶元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkStackNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkStackNode</span> *next;</span><br><span class="line">&#125;SNode,*LiStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitLinkStack</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S=(SNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LiStackEmpty</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(S-&gt;next!=<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LiStack &amp;S,ElemType e)</span></span>&#123;</span><br><span class="line">    SNode *p=(SNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=S-&gt;next;</span><br><span class="line">    S-&gt;next=p;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LiStack &amp;S,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    SNode *q=S-&gt;next;</span><br><span class="line">    e=q-&gt;data;</span><br><span class="line">    S-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(LiStack S,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e=S-&gt;next-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintListack</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历链栈：&quot;</span>;</span><br><span class="line">    SNode *p=S-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LiStack S;</span><br><span class="line">    <span class="built_in">InitLinkStack</span>(S);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">LiStackEmpty</span>(S))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链栈非空&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链栈为空&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入您要插入元素的值：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;e1;</span><br><span class="line">    <span class="keyword">while</span>(e1!=<span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Push</span>(S,e1))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;元素入栈成功！值为&quot;</span>&lt;&lt;e1&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;元素入栈失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;e1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ElemType e2=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Pop</span>(S,e2))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;元素出栈成功！值为：&quot;</span>&lt;&lt;e2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;元素出栈失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e3=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetTop</span>(S,e3))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈顶元素读取成功！！！值为：&quot;</span>&lt;&lt;e3&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈顶元素读取失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintListack</span>(S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 栈的应用-------括号匹配 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitStack(SeqStack&amp; S);				//1.初始化栈</span></span><br><span class="line"><span class="comment">// bool StackEmpty(SeqStack S);				//2.判空</span></span><br><span class="line"><span class="comment">// bool Push(SeqStack&amp; S, ElemType x);			//3.入栈</span></span><br><span class="line"><span class="comment">// bool Pop(SeqStack&amp; S, ElemType&amp; x);			//4.出栈</span></span><br><span class="line"><span class="comment">// bool BreacketCheck(char str[],int length)     //5.括号匹配逻辑代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELemType char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ELemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ELemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top++;</span><br><span class="line">    S.data[S.top]=x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ELemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    S.top--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BreacketCheck</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;(&#x27;</span>||str[i]==<span class="string">&#x27;[&#x27;</span>||str[i]==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;进栈：&quot;&lt;&lt;str[i]&lt;&lt;endl;</span></span><br><span class="line">            <span class="built_in">Push</span>(S,str[i]);&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            <span class="built_in">Pop</span>(S,topElem);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;TopElem:&quot;&lt;&lt;topElem&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;topElem!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;]&#x27;</span>&amp;&amp;topElem!=<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp;topElem!=<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">StackEmpty</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = &#123;<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;;		<span class="comment">//成功匹配</span></span><br><span class="line">	<span class="type">char</span> s2[] = &#123;<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>&#125;;		<span class="comment">//匹配失败</span></span><br><span class="line">    <span class="comment">// char str[MaxSize];</span></span><br><span class="line">    <span class="comment">// cin&gt;&gt;str;</span></span><br><span class="line">    <span class="comment">// L=strlen(str);</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">BreacketCheck</span>(s1,<span class="number">8</span>))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;匹配成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;匹配失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details>              </div>            </details><details class="folding-tag" pink><summary> 队列 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 循环队列1------（顺序存储） </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitQueue(SqQueue &amp;Q)                      //初始化队列</span></span><br><span class="line"><span class="comment">// bool QueueEmpty(SqQueue Q)                      //队列判空</span></span><br><span class="line"><span class="comment">// bool EnQueue(SqQueue &amp;Q,ElemType x)             //入队</span></span><br><span class="line"><span class="comment">// bool ExQueue(SqQueue &amp;Q,ElemType &amp;x)            //出队</span></span><br><span class="line"><span class="comment">// bool GetHead(SqQueue Q,ElemType &amp;x)             //获取队头元素</span></span><br><span class="line"><span class="comment">// void PrintQueue(SqQueue Q)                      //遍历队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=Q.rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear]=x;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ExQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=Q.data[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=Q.data[Q.front];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintQueue</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历队列：&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q.front!=Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;Q.data[Q.front]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">QueueEmpty</span>(Q))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列非空&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入要入队的元素：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;e1;</span><br><span class="line">    <span class="keyword">while</span>(e1!=<span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">EnQueue</span>(Q,e1))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;元素入队成功！值为：&quot;</span>&lt;&lt;e1&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;元素入队失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;e1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">    ElemType e2=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetHead</span>(Q,e2))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;读取队头元素成功！值为：&quot;</span>&lt;&lt;e2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;读取队头元素失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    ElemType e3=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ExQueue</span>(Q,e3))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队头元素出队成功！值为：&quot;</span>&lt;&lt;e3&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队头元素出队失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 循环队列2------（顺序存储） </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitQueue(SqQueue&amp; Q);					//1.初始化队列</span></span><br><span class="line"><span class="comment">// bool QueueEmpty(SqQueue Q);					//2.判空</span></span><br><span class="line"><span class="comment">// bool EnQueue(SqQueue&amp; Q, ElemType x);		//3.入队</span></span><br><span class="line"><span class="comment">// bool ExQueue(SqQueue&amp; Q, ElemType&amp; x);		//4.出队</span></span><br><span class="line"><span class="comment">// bool GetHead(SqQueue Q, ElemType&amp; x);		//5.获取队头元素</span></span><br><span class="line"><span class="comment">// void PrintQueue(SqQueue Q);                  //6.遍历队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.size=<span class="number">0</span>;</span><br><span class="line">    Q.front=Q.rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.size==MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear]=x;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    Q.size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ExQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=Q.data[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    Q.size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=Q.data[Q.front];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintQueue</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历队列：&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q.front!=Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;Q.data[Q.front]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">QueueEmpty</span>(Q))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列非空&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入要入队的元素值：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;e1;</span><br><span class="line">    <span class="keyword">while</span>(e1!=<span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">EnQueue</span>(Q,e1))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;元素入队成功！值为：&quot;</span>&lt;&lt;e1&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;元素入队失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;e1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">    ElemType e2=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ExQueue</span>(Q,e2))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队头元素出队成功！值为：&quot;</span>&lt;&lt;e2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队头元素出队失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e3=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetHead</span>(Q,e3))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;获取栈顶元素成功！值为：&quot;</span>&lt;&lt;e3&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;获取栈顶元素失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 循环队列3------（顺序存储） </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitQueue(SqQueue&amp; Q);					//1.初始化队列</span></span><br><span class="line"><span class="comment">// bool QueueEmpty(SqQueue Q);					//2.判空</span></span><br><span class="line"><span class="comment">// bool EnQueue(SqQueue&amp; Q, ElemType x);		//3.入队</span></span><br><span class="line"><span class="comment">// bool ExQueue(SqQueue&amp; Q, ElemType&amp; x);		//4.出队</span></span><br><span class="line"><span class="comment">// bool GetHead(SqQueue Q, ElemType&amp; x);		//5.获取队头元素</span></span><br><span class="line"><span class="comment">// void PrintQueue(SqQueue Q);                  //6.遍历队列</span></span><br><span class="line"><span class="comment">//引入辅助变量tag表示最后一次操作是入队还是出队，为判空判满提供方便且节省一个队列单元</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=<span class="number">0</span>;</span><br><span class="line">    Q.rear=MaxSize<span class="number">-1</span>;</span><br><span class="line">    Q.tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.tag==<span class="number">0</span>&amp;&amp;(Q.rear + <span class="number">1</span>) % MaxSize == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front&amp;&amp;Q.tag==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    Q.data[Q.rear]=x;</span><br><span class="line">    Q.tag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ExQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front&amp;&amp;Q.tag==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=Q.data[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    Q.tag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front&amp;&amp;Q.tag==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=Q.data[Q.front];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintQueue</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front&amp;&amp;Q.tag==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历队列：&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q.front!=Q.rear)&#123;</span><br><span class="line">        cout&lt;&lt;Q.data[Q.front]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">QueueEmpty</span>(Q))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列为空！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队列非空！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入入队的元素值：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;e1;</span><br><span class="line">    <span class="keyword">while</span>(e1!=<span class="number">9999</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">EnQueue</span>(Q,e1))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;元素入队成功！值为：&quot;</span>&lt;&lt;e1&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;元素入队失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;e1;            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">    ElemType e2=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ExQueue</span>(Q,e2))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队头元素出队成功！值为：&quot;</span>&lt;&lt;e2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队头元素出队失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ElemType e3=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">GetHead</span>(Q,e3))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;读取队头元素成功！值为：&quot;</span>&lt;&lt;e3&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;读取队头元素失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 链队列（无头结点） </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitQueue(LinkQueue &amp;Q)                                //1.初始化队列</span></span><br><span class="line"><span class="comment">// bool QueueEmpty(LinkQueue Q)                               //2.判空</span></span><br><span class="line"><span class="comment">// bool EnQueue(LinkQueue &amp;Q,ElemType x)                     //3.入队</span></span><br><span class="line"><span class="comment">// bool ExQueue(LinkQueue &amp;Q,ElemType &amp;x)                   //4.出队</span></span><br><span class="line"><span class="comment">// bool GetHead(LinkQueue Q,ElemType &amp;x)                   //5.获取队头元素</span></span><br><span class="line"><span class="comment">// void PrintQueue(LinkQueue &amp;Q)                          //6.遍历队列</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">	Q.front=Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (Q.front==<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//或者 return (Q.rear==NULL)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;     <span class="comment">//Consider two scenarios（first：当队列为空时，需要将队头指针和队尾指针同时指向新增结点，second：当队列非空时，需要将队尾指针指向的下一个结点值设为新增结点值，再将队尾指针指向新增结点）</span></span><br><span class="line">	LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">	<span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	s-&gt;data=x;</span><br><span class="line">	s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==<span class="literal">NULL</span>)</span><br><span class="line">		Q.front=Q.rear=s;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		Q.rear-&gt;next=s;</span><br><span class="line">		Q.rear=s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ExQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LinkNode *p=Q.front;</span><br><span class="line">	x=p-&gt;data;</span><br><span class="line">	Q.front=p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">		Q.front=Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(LinkQueue Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LinkNode *p=Q.front;</span><br><span class="line">	x=p-&gt;data;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;遍历队列：&quot;</span>;</span><br><span class="line">	LinkNode *p=Q.front;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LinkQueue Q;</span><br><span class="line">	<span class="built_in">InitQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">QueueEmpty</span>(Q))</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;队列为空！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;队列非空！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	ElemType e1;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;请输入入队的元素值：&quot;</span>;</span><br><span class="line">	cin&gt;&gt;e1;</span><br><span class="line">	<span class="keyword">while</span>(e1!=<span class="number">9999</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">EnQueue</span>(Q,e1))</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;新元素入队成功！值为：&quot;</span>&lt;&lt;e1&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;新元素入队失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">		cin&gt;&gt;e1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">PrintQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">	ElemType e2=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">ExQueue</span>(Q,e2))</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新元素出队成功！值为：&quot;</span>&lt;&lt;e2&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新元素出队失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ElemType e3=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">GetHead</span>(Q,e3))</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;读取队头元素成功！！！值为：&quot;</span>&lt;&lt;e3&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;读取队头元素失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">PrintQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 链队列（带头结点） </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitQueue(LinkQueue &amp;Q)                                //1.初始化队列</span></span><br><span class="line"><span class="comment">// bool QueueEmpty(LinkQueue Q)                               //2.判空</span></span><br><span class="line"><span class="comment">// bool EnQueue(LinkQueue &amp;Q,ElemType x)                     //3.入队</span></span><br><span class="line"><span class="comment">// bool ExQueue(LinkQueue &amp;Q,ElemType &amp;x)                   //4.出队</span></span><br><span class="line"><span class="comment">// bool GetHead(LinkQueue Q,ElemType &amp;x)                   //5.获取队头元素</span></span><br><span class="line"><span class="comment">// void PrintQueue(LinkQueue &amp;Q)                          //6.遍历队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElmeType int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    ElmeType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=Q.rear=(LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));        <span class="comment">//初始化时front，rear都指向头结点</span></span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EmptyQueue</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front==Q.rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElmeType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=s;</span><br><span class="line">    Q.rear=s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ExQueue</span><span class="params">(LinkQueue &amp;Q,ElmeType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==p)</span><br><span class="line">        Q.rear=Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(LinkQueue Q,ElmeType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LinkNode *s=Q.front-&gt;next;</span><br><span class="line">    x=s-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintQueue</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;遍历队列：&quot;</span>;</span><br><span class="line">    LinkNode *s=Q.front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(s!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;s-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        s=s-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LinkQueue Q;</span><br><span class="line">	<span class="built_in">InitQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">EmptyQueue</span>(Q))</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;队列为空！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;队列非空！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	ElmeType e1;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;请输入入队的元素值：&quot;</span>;</span><br><span class="line">	cin&gt;&gt;e1;</span><br><span class="line">	<span class="keyword">while</span>(e1!=<span class="number">9999</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">EnQueue</span>(Q,e1))</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;新元素入队成功！值为：&quot;</span>&lt;&lt;e1&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;新元素入队失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line">		cin&gt;&gt;e1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">PrintQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">	ElmeType e2=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">ExQueue</span>(Q,e2))</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新元素出队成功！值为：&quot;</span>&lt;&lt;e2&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;新元素出队失败！！！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	ElmeType e3=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">GetHead</span>(Q,e3))</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;读取队头元素成功！！！值为：&quot;</span>&lt;&lt;e3&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;读取队头元素失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">PrintQueue</span>(Q);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details>              </div>            </details>
              </div>
            </details>
<h1 id="串-String"><a href="#串-String" class="headerlink" title="串-String"></a>串-String</h1><details class="folding-tag" yellow><summary> 串 </summary>
              <div class='content'>
              <details class="folding-tag" blue><summary> 串的顺序存储(静态分配) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitString(SString&amp; S);									//1.初始化</span></span><br><span class="line"><span class="comment">// int StrLength(SString S);										//2.串长</span></span><br><span class="line"><span class="comment">// void ClearString(SString&amp; S);									//3.清空</span></span><br><span class="line"><span class="comment">// bool StrEmpty(SString S);										//4.判空</span></span><br><span class="line"><span class="comment">// void StrAssign(SString&amp; T, char s[]);							//5.赋值</span></span><br><span class="line"><span class="comment">// void StrCopy(SString&amp; T, SString S);							//6.复制</span></span><br><span class="line"><span class="comment">// void Concat(SString&amp; T, SString S1, SString S2);				//7.连接</span></span><br><span class="line"><span class="comment">// bool SubString(SString&amp; Sub, SString S, int pos, int len);		//8.求子串</span></span><br><span class="line"><span class="comment">// int StrCompare(SString S, SString T);							//9.比较</span></span><br><span class="line"><span class="comment">// int Index(SString S, SString T);								//10.定位</span></span><br><span class="line"><span class="comment">// void PrintString(SString S);									//11.遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">char</span> ch[MAXLEN];</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitString</span><span class="params">(SString &amp;S)</span></span>&#123;</span><br><span class="line">	S.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrLength</span><span class="params">(SString S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> S.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearString</span><span class="params">(SString &amp;S)</span></span>&#123;</span><br><span class="line">	S.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StrEmpty</span><span class="params">(SString S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (S.length==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrAssign</span><span class="params">(SString &amp;T,<span class="type">char</span> S[])</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(S[i])</span><br><span class="line">	&#123;</span><br><span class="line">		T.ch[++T.length]=S[i];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrCopy</span><span class="params">(SString &amp;T,SString S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length;i++)&#123;</span><br><span class="line">		T.ch[i]=S.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">	T.length=S.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Concat</span><span class="params">(SString &amp;T,SString S1,SString S2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S1.length;i++)&#123;</span><br><span class="line">		T.ch[i]=S1.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S2.length;i++)&#123;</span><br><span class="line">		T.ch[i+S1.length]=S2.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">	T.length=S1.length+S2.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SubString</span><span class="params">(SString &amp;Sub,SString S,<span class="type">int</span> pos,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos+len<span class="number">-1</span>&gt;S.length)                 <span class="comment">//子串从pos位置开始，长度为len</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;pos+len;i++)&#123;</span><br><span class="line">		Sub.ch[i-pos+<span class="number">1</span>]=S.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">	Sub.length=len;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrCompare</span><span class="params">(SString S,SString T)</span></span>&#123;			<span class="comment">//因为有三种情况，&gt;,&lt;,=：所以用int值返回，bool只能返回两种类型</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;S.length&amp;&amp;i&lt;T.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(S.ch[i]!=T.ch[i])</span><br><span class="line">			<span class="keyword">return</span> S.ch[i]-T.ch[i];            <span class="comment">//如果两个数不相等，则比较两个数的值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> S.length-T.length;               <span class="comment">//如果扫描过的字符都相同，则比较谁的长度更长</span></span><br><span class="line">&#125;           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S,SString T)</span></span>&#123;     <span class="comment">//定位操作：若主串中存在于串T值相同的子串，则返回它在主串中第一次出现的位置，否则函数值为0，即不存在</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>,n=<span class="built_in">StrLength</span>(S),m=<span class="built_in">StrLength</span>(T);</span><br><span class="line">	SString Sub;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;n-m+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">SubString</span>(Sub,S,i,m);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">StrCompare</span>(Sub,T)!=<span class="number">0</span>)</span><br><span class="line">			++i;</span><br><span class="line">		<span class="keyword">else</span>	</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintString</span><span class="params">(SString S)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length;i++)&#123;</span><br><span class="line">		cout&lt;&lt;S.ch[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*1、赋值操作*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;赋值操作S1--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    SString S1;</span><br><span class="line">    <span class="built_in">InitString</span>(S1);</span><br><span class="line">    <span class="type">char</span> ch[]=<span class="string">&quot;321&quot;</span>;</span><br><span class="line">    <span class="built_in">StrAssign</span>(S1,ch);</span><br><span class="line">    <span class="built_in">PrintString</span>(S1);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;复制操作S2--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    SString S2;</span><br><span class="line">    <span class="built_in">StrCopy</span>(S2,S1);</span><br><span class="line">    <span class="built_in">PrintString</span>(S2);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;联接操作S3--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    SString S3;</span><br><span class="line">    <span class="built_in">Concat</span>(S3,S1,S2);</span><br><span class="line">    <span class="built_in">PrintString</span>(S3);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;求子串操作S4--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    SString S4;</span><br><span class="line">    <span class="type">int</span> pos,len;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入起点和长度：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;pos&gt;&gt;len;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">SubString</span>(S4,S3,pos,len))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;所求子串为：&quot;</span>;</span><br><span class="line">        <span class="built_in">PrintString</span>(S4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;子串范围越界！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;比较操作--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(S1,S2)==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;S1=S2!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(S1,S2)&gt;<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;S1&gt;S2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(S1,S2)&lt;<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;S1&lt;S2&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;定位操作--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Index</span>(S3,S4)==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;S4不是S3的子串！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;子串S4在S3中的位置为：&quot;</span>&lt;&lt;<span class="built_in">Index</span>(S3,S4)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 串的顺序存储(动态分配) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitString(HString&amp; S);									//1.初始化</span></span><br><span class="line"><span class="comment">// void IncreaseSize(HString&amp; S, int len);							//2.扩容</span></span><br><span class="line"><span class="comment">// int StrLength(HString S);										//3.串长</span></span><br><span class="line"><span class="comment">// void ClearString(HString&amp; S);									//4.清空</span></span><br><span class="line"><span class="comment">// bool StrEmpty(HString S);										//5.判空</span></span><br><span class="line"><span class="comment">// void StrAssign(HString&amp; T, char s[]);							//6.赋值</span></span><br><span class="line"><span class="comment">// void StrCopy(HString&amp; T, HString S);							//7.复制</span></span><br><span class="line"><span class="comment">// void Concat(HString&amp; T, HString S1, HString S2);				//8.连接</span></span><br><span class="line"><span class="comment">// bool SubString(HString&amp; Sub, HString S, int pos, int len);		//9.求子串</span></span><br><span class="line"><span class="comment">// int StrCompare(HString S, HString T);							//10.比较</span></span><br><span class="line"><span class="comment">// int Index(HString S, HString T);								//11.定位</span></span><br><span class="line"><span class="comment">// void DestroyString(HString&amp; S);									//12.销毁</span></span><br><span class="line"><span class="comment">// void PrintString(HString S);									//13.遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ch;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitHString</span><span class="params">(HString &amp;S)</span></span>&#123;</span><br><span class="line">    S.ch=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*MAXLEN);</span><br><span class="line">    S.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void IncreaseSize(HString&amp; S, int len);							//2.扩容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">(HString &amp;S,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p=S.ch;</span><br><span class="line">    S.ch=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*(MAXLEN+len));             </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length;i++)&#123;                   <span class="comment">//将数据复制到新区域（时间开销大）</span></span><br><span class="line">        S.ch[i]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    S.length+=len;                      <span class="comment">//串的长度增加len</span></span><br><span class="line">    <span class="built_in">free</span>(p);                           <span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int StrLength(HString S);										//3.串长</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrLength</span><span class="params">(HString S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void ClearString(HString&amp; S);									//4.清空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearString</span><span class="params">(HString &amp;S)</span></span>&#123;</span><br><span class="line">    S.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bool StrEmpty(HString S);										//5.判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StrEmpty</span><span class="params">(HString S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(S.length==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void StrAssign(HString&amp; T, char s[]);							//6.赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrAssign</span><span class="params">(HString &amp;T,<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i])&#123;</span><br><span class="line">        T.ch[++T.length]=s[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void StrCopy(HString&amp; T, HString S);							//7.复制    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrCopy</span><span class="params">(HString &amp;T,HString S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length;i++)&#123;</span><br><span class="line">        T.ch[i]=S.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    T.length=S.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void Concat(HString&amp; T, HString S1, HString S2);				//8.连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Concat</span><span class="params">(HString &amp;T,HString S1,HString S2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S1.length;i++)&#123;</span><br><span class="line">        T.ch[i]=S1.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S2.length;i++)&#123;</span><br><span class="line">        T.ch[i+S1.length]=S2.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    T.length=S1.length+S2.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// bool SubString(HString&amp; Sub, HString S, int pos, int len);		//9.求子串</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SubString</span><span class="params">(HString &amp;Sub,HString S,<span class="type">int</span> pos,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.length&lt;pos+len+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;pos+len;i++)&#123;</span><br><span class="line">        Sub.ch[i-pos+<span class="number">1</span>]=S.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Sub.length=len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int StrCompare(HString S, HString T);							//10.比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrCompare</span><span class="params">(HString S,HString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length&amp;&amp;i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]!=T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i]-T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int Index(HString S, HString T);								//11.定位</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(HString S,HString T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,n=<span class="built_in">StrLength</span>(S),m=<span class="built_in">StrLength</span>(T);</span><br><span class="line">    HString Sub;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SubString</span>(Sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(Sub,T)!=<span class="number">0</span>)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void DestroyString(HString&amp; S);									//12.销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyString</span><span class="params">(HString &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(S.ch);</span><br><span class="line">    S.ch=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void PrintString(HString S);									//13.遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintString</span><span class="params">(HString S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;S.ch[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;赋值操作-S1-&quot;</span>&lt;&lt;endl;</span><br><span class="line">    HString S1;</span><br><span class="line">    <span class="built_in">InitHString</span>(S1);</span><br><span class="line">    <span class="type">char</span> ch[]=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="built_in">StrAssign</span>(S1,ch);</span><br><span class="line">    <span class="built_in">PrintString</span>(S1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;复制操作S2--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    HString S2;</span><br><span class="line">    <span class="built_in">InitHString</span>(S2);</span><br><span class="line">    <span class="built_in">StrCopy</span>(S2,S1);</span><br><span class="line">    <span class="built_in">PrintString</span>(S2);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;联接操作S3--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    HString S3;</span><br><span class="line">    <span class="built_in">InitHString</span>(S3);</span><br><span class="line">    <span class="built_in">Concat</span>(S3,S1,S2);</span><br><span class="line">    <span class="built_in">PrintString</span>(S3);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;求子串操作S4--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    HString S4;</span><br><span class="line">    <span class="built_in">InitHString</span>(S4);</span><br><span class="line">    <span class="type">int</span> pos,len;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入起点和操作--&quot;</span>;</span><br><span class="line">    cin&gt;&gt;pos&gt;&gt;len;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">SubString</span>(S4,S3,pos,len))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;所求子串为:&quot;</span>;</span><br><span class="line">        <span class="built_in">PrintString</span>(S4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;子串范围越界!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;比较操作--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(S1,S2)==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;S1=S2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(S1,S2)&lt;<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;S1&lt;S2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(S1,S2)&gt;<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;S1&gt;S2&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;定位操作--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Index</span>(S3,S4)==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;S4不是S3的子串！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;子串S4在S3中的位置为：&quot;</span>&lt;&lt;<span class="built_in">Index</span>(S3,S4)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁操作</span></span><br><span class="line">    <span class="built_in">DestroyString</span>(S1);</span><br><span class="line">    <span class="built_in">DestroyString</span>(S2);</span><br><span class="line">    <span class="built_in">DestroyString</span>(S3);</span><br><span class="line">    <span class="built_in">DestroyString</span>(S4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 串的模式匹配 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素模式匹配算法：Index1与Index2的区别在于，Index1加入了一个辅助变量去记录回溯位置。</span></span><br><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitString(String&amp; S);							//1.初始化</span></span><br><span class="line"><span class="comment">// void StrAssign(String&amp; T, char s[]);				//2.赋值操作</span></span><br><span class="line"><span class="comment">// int Index1(String S, String T);						//3.朴素(简单)模式匹配算法1</span></span><br><span class="line"><span class="comment">// int Index2(String S, String T);						//4.朴素(简单)模式匹配算法2</span></span><br><span class="line"><span class="comment">// void get_next(String T, int next[]);				//5.求next数组</span></span><br><span class="line"><span class="comment">// int Index_KMP(String S, String T, int next[]);		//6.改进的模式匹配算法-KMP算法</span></span><br><span class="line"><span class="comment">// void get_nextval(String T, int nextval[]);			//7.next数组的优化-求nxetval数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;String;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitString</span><span class="params">(String &amp;S)</span></span>&#123;</span><br><span class="line">    S.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrAssign</span><span class="params">(String &amp;T,<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[i])&#123;</span><br><span class="line">        T.ch[++T.length]=s[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//朴素(简单)模式匹配算法1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index1</span><span class="params">(String S,String T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;                       <span class="comment">//用来记录是第几个子串</span></span><br><span class="line">    <span class="type">int</span> i=k,j=<span class="number">1</span>;                   <span class="comment">//i指向主串S中的当前匹配子串的位序，j指向模式串T的位序</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;       <span class="comment">//若当前模式串和子串同位序的值相等，对比下个位序</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                       <span class="comment">//若不相等，则对比下个子串</span></span><br><span class="line">            i=++k;                  <span class="comment">//k先指向下个子串，再把k当前所指的下标，即下个子串位序为1赋值给i</span></span><br><span class="line">            j=<span class="number">1</span>;                    <span class="comment">//j指向模式串的首位，重新匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)              <span class="comment">//若是因为j&gt;T.length退出while循环,说明模式串扫描完毕，匹配成功，返回当前k所指子串</span></span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span>                        <span class="comment">//若是因为j&gt;S.length退出while循环,当前扫描的子串为最后一个子串，且子串&lt;模式串，匹配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//朴素(简单)模式匹配算法2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index2</span><span class="params">(String S,String T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;                    </span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;                <span class="comment">//i-j+1反映的是当前是主串中的第几个子串，再+1说明i指向下个子串的首位</span></span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)                 <span class="comment">//若是因为j&gt;T.length退出while循环，说明模式串扫描完毕，匹配成功，返回当前i-j+1</span></span><br><span class="line">        <span class="keyword">return</span> i-j+<span class="number">1</span>;              <span class="comment">//或者i-T.length;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                  <span class="comment">//若是因为i&gt;S.length退出while循环，当前扫描的子串为最后一个子串，且子串&lt;模式串，匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求next数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(String T,<span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||T.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;                   <span class="comment">//若pi=pj；则next[j+1]=next[j]+1</span></span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j];         <span class="comment">//否则令j=next[j]，循环继续</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进的模式匹配算法-KMP算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(String S,String T,<span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//next数组优化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nextval</span><span class="params">(String T,<span class="type">int</span> nextval[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||T.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span>(T.ch[i]!=T.ch[j])</span><br><span class="line">                nextval[i]=j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i]=nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求nextval数组(王道书)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nextval2</span><span class="params">(String T,<span class="type">int</span> next[],<span class="type">int</span> nextval[])</span></span>&#123;</span><br><span class="line">    nextval[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=T.length;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T.ch[next[j]]==T.ch[j])</span><br><span class="line">            nextval[j]=nextval[next[j]];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nextval[j]=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintString</span><span class="params">(String S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;S.ch[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String S1;</span><br><span class="line">    <span class="built_in">InitString</span>(S1);</span><br><span class="line">	<span class="type">char</span> s1[] = <span class="string">&quot;zx123&quot;</span>;</span><br><span class="line">    <span class="built_in">StrAssign</span>(S1,s1);</span><br><span class="line">    <span class="built_in">PrintString</span>(S1);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    String S2;</span><br><span class="line">    <span class="built_in">InitString</span>(S2);</span><br><span class="line">	<span class="type">char</span> s2[] = <span class="string">&quot;23&quot;</span>;</span><br><span class="line">    <span class="built_in">StrAssign</span>(S2,s2);</span><br><span class="line">    <span class="built_in">PrintString</span>(S2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*1、朴素模式匹配算法*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Index1</span>(S1,S2)==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;匹配失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;模式串在主串的位序为：&quot;</span>&lt;&lt;<span class="built_in">Index2</span>(S1,S2)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2、朴素模式匹配算法优化-KMP算法*/</span></span><br><span class="line">    <span class="type">int</span> next[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">get_next</span>(S2,next);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Index_KMP</span>(S1,S2,next)==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;匹配失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;模式串在主串的位序为：&quot;</span>&lt;&lt;<span class="built_in">Index2</span>(S1,S2)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*3、优化KMP算法*/</span></span><br><span class="line">    <span class="type">int</span> nextval[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">get_next</span>(S2,nextval);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Index_KMP</span>(S1,S2,nextval)==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;匹配失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;模式串在主串的位序为：&quot;</span>&lt;&lt;<span class="built_in">Index2</span>(S1,S2)&lt;&lt;endl;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details>
              </div>
            </details>
<h1 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树-Tree"></a>树-Tree</h1><details class="folding-tag" yellow><summary> 树 </summary>
              <div class='content'>
              <details class="folding-tag" blue><summary> 二叉树链式存储 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void CreateBiTree(BiTree&amp; T);	//1.先序建立二叉树</span></span><br><span class="line"><span class="comment">// int TreeDepth(BiTree T);		//2.求树的深度</span></span><br><span class="line"><span class="comment">// void visit(BiTNode* q);			//3-1.找中序前驱-访问结点</span></span><br><span class="line"><span class="comment">// void FindPre(BiTree T);			//3-2.找中序前驱-中序遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType char</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild,*rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        T-&gt;data=c;</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeDepth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">TreeDepth</span>(T-&gt;lchild);		<span class="comment">//递归求出左子树深度</span></span><br><span class="line">		<span class="type">int</span> r = <span class="built_in">TreeDepth</span>(T-&gt;rchild);		<span class="comment">//递归求出右子树深度</span></span><br><span class="line">		<span class="keyword">return</span> l &gt; r ? l + <span class="number">1</span> : r + <span class="number">1</span>;		<span class="comment">//树的深度=Max(左子树深度，右子树深度)+1 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助全局变量，用于查找p的前驱</span></span><br><span class="line">BiTNode* p;					<span class="comment">//p指向目标结点</span></span><br><span class="line">BiTNode* pre = <span class="literal">NULL</span>;		<span class="comment">//pre指向当前访问结点的前驱</span></span><br><span class="line">BiTNode* <span class="keyword">final</span> = <span class="literal">NULL</span>;		<span class="comment">//用于记录最终结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BiTNode *q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (q == p)			<span class="comment">//当前访问结点刚好是p</span></span><br><span class="line">		<span class="keyword">final</span> = pre;	<span class="comment">//找到p的前驱，用final记录</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pre = q;		<span class="comment">//pre指向当前访问的结点，继续递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindPre</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">FindPre</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">        <span class="built_in">FindPre</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序二叉树:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreateBiTree</span>(T);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;该二叉树的深度为：&quot;</span>&lt;&lt;<span class="built_in">TreeDepth</span>(T)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    p = T;</span><br><span class="line">    <span class="built_in">FindPre</span>(T);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;根结点的中序前驱为：&quot;</span>&lt;&lt;<span class="keyword">final</span>-&gt;data&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 二叉树的的先序中序后序遍历------递归实现 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void CreateBiTree(BiTree&amp; T);	//1.先序建立二叉树</span></span><br><span class="line"><span class="comment">// void visit(BiTNode* p);			//2.打印结点值</span></span><br><span class="line"><span class="comment">// void PreOrder(BiTree T);		//3.先序遍历	</span></span><br><span class="line"><span class="comment">// void InOrder(BiTree T);			//4.中序遍历</span></span><br><span class="line"><span class="comment">// void PostOrder(BiTree T);		//5.后序遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树结点类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">	ElemType data;		<span class="comment">//结点中的数据域</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiTNode</span>* lchild, * rchild;	<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode, * BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree&amp; T)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	cin&gt;&gt;c;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">		T = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		T = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">		T-&gt;data = c;</span><br><span class="line">		<span class="built_in">CreateBiTree</span>(T-&gt;lchild);</span><br><span class="line">		<span class="built_in">CreateBiTree</span>(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.打印结点-用于遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BiTNode* p)</span> </span>&#123;</span><br><span class="line">	cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.先序遍历（根-&gt;左-&gt;右）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">visit</span>(T);				<span class="comment">//访问根结点</span></span><br><span class="line">		<span class="built_in">PreOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">PreOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.中序遍历（左-&gt;根-&gt;右）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">InOrder</span>(T-&gt;lchild);		<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">visit</span>(T);				<span class="comment">//访问根结点</span></span><br><span class="line">		<span class="built_in">InOrder</span>(T-&gt;rchild);		<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.后序遍历（左-&gt;右-&gt;根）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">PostOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">PostOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">		<span class="built_in">visit</span>(T);				<span class="comment">//访问根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BiTree T;			<span class="comment">//声明一个二叉树</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*1、先序创建二叉树*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序创建二叉树:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">CreateBiTree</span>(T);	<span class="comment">//先序建立二叉树</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*2、先序遍历二叉树*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">PreOrder</span>(T);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*3、中序遍历二叉树*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;中序遍历&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">InOrder</span>(T);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*4、后序遍历二叉树*/</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;后序遍历&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">PostOrder</span>(T);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 二叉树的的先序中序后序遍历------非递归实现 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void CreateBiTree(BiTree&amp; T);			//1.先序建立二叉树</span></span><br><span class="line"><span class="comment">// bool InitLinkStack(LiStack&amp; S);			//2.初始化链栈</span></span><br><span class="line"><span class="comment">// bool LiStackEmpty(LiStack S);			//3.判空</span></span><br><span class="line"><span class="comment">// bool Push(LiStack&amp; S, ElemType e);		//4.入栈</span></span><br><span class="line"><span class="comment">// bool Pop(LiStack&amp; S, ElemType&amp; e);		//5.出栈</span></span><br><span class="line"><span class="comment">// bool GetTop(LiStack S, ElemType&amp; e);	//6.获取栈顶元素</span></span><br><span class="line"><span class="comment">// void visit(BiTNode* p);					//7.打印结点值</span></span><br><span class="line"><span class="comment">// void PreOrder(BiTree T);				//8.先序遍历	</span></span><br><span class="line"><span class="comment">// void InOrder(BiTree T);					//9.中序遍历</span></span><br><span class="line"><span class="comment">// void PostOrder(BiTree T);				//10.后序遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType BiTNode*</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType1 char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树结点类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    ElemType1 data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild,*rchild;</span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助栈类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkStackNode</span>&#123;         <span class="comment">//链栈类型定义</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkStackNode</span> *next;      <span class="comment">//指针域</span></span><br><span class="line">&#125;SNode,*LiStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">        T-&gt;data=c;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitLinkStack</span><span class="params">(LiStack &amp;S)</span></span>&#123;</span><br><span class="line">    S=(SNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));          <span class="comment">//分配头结点</span></span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//内存不足，分配失败</span></span><br><span class="line">    S-&gt;next=<span class="literal">NULL</span>;                  <span class="comment">//头结点之后暂时没有结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LiStackEmpty</span><span class="params">(LiStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S-&gt;next==<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LiStack &amp;S,ElemType e)</span></span>&#123;</span><br><span class="line">    SNode*p=(SNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SNode));</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)     <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=S-&gt;next;</span><br><span class="line">    S-&gt;next=p;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LiStack &amp;S,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//栈空，报错</span></span><br><span class="line">	SNode* q = S-&gt;next;		<span class="comment">//找到当前链栈的栈顶结点</span></span><br><span class="line">	e = q-&gt;data;			<span class="comment">//返回栈顶结点的值</span></span><br><span class="line">    S-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(LiStack S,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//栈空，报错</span></span><br><span class="line">    e=S-&gt;next-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BiTNode *p)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    LiStack S;				<span class="comment">//声明一个链栈</span></span><br><span class="line">	<span class="built_in">InitLinkStack</span>(S);		<span class="comment">//初始化栈			</span></span><br><span class="line">	BiTree p = T;			<span class="comment">//p是遍历指针</span></span><br><span class="line">	<span class="keyword">while</span> (p || !<span class="built_in">LiStackEmpty</span>(S)) &#123;		<span class="comment">//栈不空或者p不空时循环</span></span><br><span class="line">		<span class="keyword">if</span> (p) &#123;			<span class="comment">//一路向左</span></span><br><span class="line">			<span class="built_in">visit</span>(p);		<span class="comment">//访问当前结点</span></span><br><span class="line">			<span class="built_in">Push</span>(S, p);		<span class="comment">//当前结点入栈</span></span><br><span class="line">			p = p-&gt;lchild;	<span class="comment">//左孩子不空，一直向左</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;				<span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">			<span class="built_in">Pop</span>(S, p);		<span class="comment">//栈顶元素出栈</span></span><br><span class="line">			p = p-&gt;rchild;	<span class="comment">//向右子树走，p赋值为当前结点右孩子</span></span><br><span class="line">		&#125;<span class="comment">//返回while循环继续进入if-else语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    LiStack S;				<span class="comment">//声明一个链栈</span></span><br><span class="line">	<span class="built_in">InitLinkStack</span>(S);		<span class="comment">//初始化栈			</span></span><br><span class="line">	BiTree p = T;			<span class="comment">//p是遍历指针</span></span><br><span class="line">	<span class="keyword">while</span> (p || !<span class="built_in">LiStackEmpty</span>(S)) &#123;		<span class="comment">//栈不空或者p不空时循环</span></span><br><span class="line">		<span class="keyword">if</span> (p) &#123;			<span class="comment">//一路向左</span></span><br><span class="line">			<span class="built_in">Push</span>(S, p);		<span class="comment">//当前结点入栈</span></span><br><span class="line">			p = p-&gt;lchild;	<span class="comment">//左孩子不空，一直向左</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;				<span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">			<span class="built_in">Pop</span>(S, p);		<span class="comment">//栈顶元素出栈</span></span><br><span class="line">			<span class="built_in">visit</span>(p);		<span class="comment">//访问出栈结点</span></span><br><span class="line">			p = p-&gt;rchild;	<span class="comment">//向右子树走，p赋值为当前结点右孩子</span></span><br><span class="line">		&#125;<span class="comment">//返回while循环继续进入if-else语句</span></span><br><span class="line">	&#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	LiStack S;				<span class="comment">//声明一个链栈</span></span><br><span class="line">	<span class="built_in">InitLinkStack</span>(S);		<span class="comment">//初始化栈			</span></span><br><span class="line">	BiTree p = T;			<span class="comment">//p是遍历指针</span></span><br><span class="line">	BiTNode* r = <span class="literal">NULL</span>;		<span class="comment">//辅助指针，指向最近访问过的结点，用于记录是否已被访问</span></span><br><span class="line">	<span class="keyword">while</span> (p || !<span class="built_in">LiStackEmpty</span>(S)) &#123;	<span class="comment">//栈不空或者p不空时循环</span></span><br><span class="line">		<span class="keyword">if</span> (p) &#123;<span class="comment">/*一路向左*/</span></span><br><span class="line">			<span class="built_in">Push</span>(S, p);			<span class="comment">//当前结点入栈</span></span><br><span class="line">			p = p-&gt;lchild;		<span class="comment">//左孩子不空，一直向左</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">/*左空，向右*/</span></span><br><span class="line">			<span class="built_in">GetTop</span>(S, p);	<span class="comment">//获取栈顶元素</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;rchild &amp;&amp; p-&gt;rchild != r) &#123;<span class="comment">/*若右子树存在，且未被访问过*/</span></span><br><span class="line">				p = p-&gt;rchild;		<span class="comment">//转向右</span></span><br><span class="line">				<span class="built_in">Push</span>(S, p);			<span class="comment">//压入栈</span></span><br><span class="line">				p = p-&gt;lchild;		<span class="comment">//再走到最左</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">/*否则，弹出结点并访问*/</span></span><br><span class="line">				<span class="built_in">Pop</span>(S, p);		<span class="comment">//栈顶元素出栈</span></span><br><span class="line">				<span class="built_in">visit</span>(p);		<span class="comment">//访问出栈结点</span></span><br><span class="line">				r = p;			<span class="comment">//记录最近访问过的结点</span></span><br><span class="line">				p = <span class="literal">NULL</span>;		<span class="comment">//结点访问完后，重置p指针</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">//else</span></span><br><span class="line">	&#125;<span class="comment">//while</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BiTree T;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;先序创建二叉树：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">CreatBiTree</span>(T);</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;先序遍历：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">PreOrder</span>(T);</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;中序遍历：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">Inorder</span>(T);</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;后序遍历：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">PostOrder</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 二叉树的层次遍历(队列的应用) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的层次遍历(队列的应用)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void InitQueue(LinkQueue&amp; Q);				//1.初始化队列</span></span><br><span class="line"><span class="comment">// bool LiQueueEmpty(LinkQueue Q);				//2.判空</span></span><br><span class="line"><span class="comment">// bool EnQueue(LinkQueue&amp; Q, ElemType x);		//3.入队操作	</span></span><br><span class="line"><span class="comment">// bool ExQueue(LinkQueue&amp; Q, ElemType&amp; x);	//4.出队操作</span></span><br><span class="line"><span class="comment">// void CreateBiTree(BiTree&amp; T);				//5.先序建立二叉树</span></span><br><span class="line"><span class="comment">// void visit(BiTNode* p);						//6.打印结点</span></span><br><span class="line"><span class="comment">// void LevelOrder(BiTree T);					//7.二叉树的层次遍历	</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType BiTNode*</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELemTypel char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.二叉树结点类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">	ELemTypel data;		<span class="comment">//结点中的数据域</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiTNode</span>* lchild, * rchild;	<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode, * BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.辅助队列结点类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;		</span><br><span class="line">	BiTNode* data;				<span class="comment">//存指针而不是结点</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkNode</span>* next;		<span class="comment">//指向下一个结点的指针</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.辅助队列类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;				</span><br><span class="line">	LinkNode* front, * rear;	<span class="comment">//队列的队头指针和队尾指针 </span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front=Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LiQueueEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.front == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.入队操作(无头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, ElemType x)</span> </span>&#123;</span><br><span class="line">	LinkNode* s = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//内存不足，分配失败</span></span><br><span class="line">	s-&gt;data = x;		<span class="comment">//为新结点赋值</span></span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;		<span class="comment">//因为新结点只能从队尾插入，即新结点为最后一个结点，其next指针为NULL</span></span><br><span class="line">	<span class="keyword">if</span> (Q.rear == <span class="literal">NULL</span>)		<span class="comment">//如果当前队列为空，入队结点为第一个结点</span></span><br><span class="line">		Q.front = Q.rear = s;	<span class="comment">//修改队头和队尾指针</span></span><br><span class="line">	<span class="keyword">else</span> &#123;				<span class="comment">//其他结点的插入与带头结点的插入一致</span></span><br><span class="line">		Q.rear-&gt;next = s;		<span class="comment">//新结点插入到rear之后：原先队尾指针所指结点的next指向新结点</span></span><br><span class="line">		Q.rear = s;			<span class="comment">//修改队尾结点指针，指向新的队尾结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出队操作(无头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ExQueue</span><span class="params">(LinkQueue&amp; Q, ElemType&amp; x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//队空，报错</span></span><br><span class="line">	LinkNode* p = Q.front;	<span class="comment">//找到队头元素</span></span><br><span class="line">	x = p-&gt;data;				<span class="comment">//变量x返回队头元素</span></span><br><span class="line">	Q.front = p-&gt;next;	<span class="comment">//修改队头指针：将队头结点的后继结点赋给队头指针</span></span><br><span class="line">	<span class="keyword">if</span> (Q.rear == p)			<span class="comment">//如果此次为最后一个结点出队	</span></span><br><span class="line">		Q.rear = Q.front = <span class="literal">NULL</span>;		<span class="comment">//修改rear指针,队列置空</span></span><br><span class="line">	<span class="built_in">free</span>(p);		<span class="comment">//释放结点空间</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree&amp; T)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	cin&gt;&gt;c;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">		T = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		T = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">		T-&gt;data = c;</span><br><span class="line">		<span class="built_in">CreateBiTree</span>(T-&gt;lchild);</span><br><span class="line">		<span class="built_in">CreateBiTree</span>(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BiTNode *p)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.二叉树的层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">	LinkQueue Q;</span><br><span class="line">	<span class="built_in">InitQueue</span>(Q);		<span class="comment">//初始化辅助队列</span></span><br><span class="line">	BiTree p;</span><br><span class="line">	<span class="built_in">EnQueue</span>(Q, T);			<span class="comment">//根结点入队</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">LiQueueEmpty</span>(Q)) &#123;		<span class="comment">//队列不空则循环</span></span><br><span class="line">		<span class="built_in">ExQueue</span>(Q, p);		<span class="comment">//队头结点出队</span></span><br><span class="line">		<span class="built_in">visit</span>(p);					<span class="comment">//访问出队结点</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">EnQueue</span>(Q, p-&gt;lchild);		<span class="comment">//左子树不空，则左子树根结点入队</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">EnQueue</span>(Q, p-&gt;rchild);		<span class="comment">//右子树不空，则右子树根结点入队</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序创建二叉树：&quot;</span>;</span><br><span class="line">    <span class="built_in">CreateBiTree</span>(T);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;层次遍历二叉树：&quot;</span>;</span><br><span class="line">    <span class="built_in">LevelOrder</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 线索二叉树(中序) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树(中序)</span></span><br><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void CreateThTree(ThreadTree&amp; T);			//1.先序建立线索二叉树</span></span><br><span class="line"><span class="comment">// void InitThread(ThreadTree&amp; T);				//2.初始化tag</span></span><br><span class="line"><span class="comment">// void visit1(ThreadNode* q);					//3-1.访问并建立线索</span></span><br><span class="line"><span class="comment">// void InThread(ThreadTree T);				//3-2.遍历</span></span><br><span class="line"><span class="comment">// void CreateInThread(ThreadTree T);			//3-3.中序线索化主过程</span></span><br><span class="line"><span class="comment">// ThreadNode* FirstNode(ThreadNode* p);		//4-1.找到以p为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line"><span class="comment">// ThreadNode* NextNode(ThreadNode* p);		//4-2.找到p的后继结点</span></span><br><span class="line"><span class="comment">// ThreadNode* LastNode(ThreadNode* p);		//5-1.找到以p为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line"><span class="comment">// ThreadNode* PreNode(ThreadNode* p);			//5-2.找到p的前驱结点	</span></span><br><span class="line"><span class="comment">// void visit2(ThreadNode* p);					//6-1.打印结点</span></span><br><span class="line"><span class="comment">// void InOrder(ThreadNode* T);				//6-2.利用中序后继实现中序遍历</span></span><br><span class="line"><span class="comment">// void RevInOrder(ThreadNode* T);				//6-3.利用中序前驱实现逆向中序遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELemType char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">	ELemType data;							<span class="comment">//数据元素</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ThreadNode</span>* lchild, * rchild;	<span class="comment">//左、右孩子指针</span></span><br><span class="line">	<span class="type">int</span> ltag, rtag;							<span class="comment">//左、右线索标志</span></span><br><span class="line">	<span class="comment">//tag=0,表示指针指向孩子;tag=1,表示指针是“线索”,ltag指向前驱，rtag指向后继</span></span><br><span class="line">&#125;ThreadNode, * ThreadTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateThTree</span><span class="params">(ThreadTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=(ThreadNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ThreadNode));</span><br><span class="line">        T-&gt;data=c;</span><br><span class="line">        <span class="built_in">CreateThTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateThTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.初始化tag*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitThread</span><span class="params">(ThreadTree&amp; T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		T-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">		T-&gt;rtag = <span class="number">0</span>;	<span class="comment">//初始化当前树中的tag指针为0，表示还未线索化</span></span><br><span class="line">		<span class="built_in">InitThread</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">InitThread</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ThreadNode* pre = <span class="literal">NULL</span>;		<span class="comment">//pre指向当前访问结点的前驱</span></span><br><span class="line"><span class="comment">//3-1.访问并建立线索</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit1</span><span class="params">(ThreadNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">		q-&gt;lchild = pre;</span><br><span class="line">		q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;	</span><br><span class="line">		pre-&gt;rchild = q;	<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">		pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pre = q;			<span class="comment">//标记当前结点为刚刚访问过的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">visit1</span>(T);</span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3-3.主过程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">	pre = <span class="literal">NULL</span>;			<span class="comment">//pre初始化为NULL</span></span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;	<span class="comment">//非空二叉树才能线索化			</span></span><br><span class="line">		<span class="built_in">InThread</span>(T);	<span class="comment">//中序线索化二叉树</span></span><br><span class="line">		<span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)	<span class="comment">//实际上不用判断，中序遍历时最后一个结点的右孩子指针必为NULL</span></span><br><span class="line">			pre-&gt;rtag = <span class="number">1</span>;			<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-1.求中序线索二叉树中中序遍历的第一个结点：右子树中最左下的结点</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">FirstNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//循环找到最左下结点(不一定是叶节点)</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">		p = p-&gt;lchild;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-2.找到p的后继结点</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>)		<span class="comment">//若rtag=0，说明所找结点有右孩子，则找该结点的右子树最左下结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> p-&gt;rchild;	<span class="comment">//若rtag=1，说明所找结点无右孩子，则返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5-1.求中序线索二叉树中中序遍历的最后一个结点：左子树中最右下的结点</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">LastNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//循环找到最右下结点(不一定是叶节点)</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">		p = p-&gt;rchild;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5-2.找到p的前驱结点</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">PreNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)		<span class="comment">//若ltag=0，说明所找结点有左孩子，则找该结点的左子树最右下结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">LastNode</span>(p-&gt;lchild);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> p-&gt;lchild;	<span class="comment">//若ltag=1，说明所找结点无左孩子，则返回前驱线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6-2.利用中序后继实现中序遍历：空间复杂度为O(1) </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode* T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (ThreadNode* p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">NULL</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line">		<span class="built_in">visit2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6-2.利用中序后继实现中序遍历：空间复杂度为O(1) </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RevInOrder</span><span class="params">(ThreadNode* T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (ThreadNode* p = <span class="built_in">LastNode</span>(T); p != <span class="literal">NULL</span>; p = <span class="built_in">PreNode</span>(p))</span><br><span class="line">		<span class="built_in">visit2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ThreadTree T;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序创建二叉树：&quot;</span>;</span><br><span class="line">    <span class="built_in">CreateThTree</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitThread</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CreateInThread</span>(T);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;根节点的中序后继为:&quot;</span>&lt;&lt;<span class="built_in">NextNode</span>(T)-&gt;data&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;根节点的中序前驱为：&quot;</span>&lt;&lt;<span class="built_in">PreNode</span>(T)-&gt;data&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;中序遍历：&quot;</span>;</span><br><span class="line">    <span class="built_in">InOrder</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;逆向中序遍历：&quot;</span>;</span><br><span class="line">    <span class="built_in">RevInOrder</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 线索二叉树(先序) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树（先序）</span></span><br><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void CreateThTree(ThreadTree&amp; T);			//1.先序建立线索二叉树</span></span><br><span class="line"><span class="comment">// void InitThread(ThreadTree&amp; T);				//2.初始化tag</span></span><br><span class="line"><span class="comment">// void visit1(ThreadNode* q);					//3-1.访问并建立线索</span></span><br><span class="line"><span class="comment">// void PreThread(ThreadTree T);				//3-2.遍历</span></span><br><span class="line"><span class="comment">// void CreatePreThread(ThreadTree T);			//3-3.先序线索化主过程</span></span><br><span class="line"><span class="comment">// ThreadNode* NextNode(ThreadNode* p);		//4.找到p的后继结点</span></span><br><span class="line"><span class="comment">// void visit2(ThreadNode* p);					//5-1.打印结点</span></span><br><span class="line"><span class="comment">// void PreOrder(ThreadNode* T);				//5-2.利用先序后继实现先序遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELemType char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">	ELemType data;							<span class="comment">//数据元素</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ThreadNode</span>* lchild, * rchild;	<span class="comment">//左、右孩子指针</span></span><br><span class="line">	<span class="type">int</span> ltag, rtag;							<span class="comment">//左、右线索标志</span></span><br><span class="line">	<span class="comment">//tag=0,表示指针指向孩子;tag=1,表示指针是“线索”,ltag指向前驱，rtag指向后继</span></span><br><span class="line">&#125;ThreadNode, * ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateThTree</span><span class="params">(ThreadTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        T=(ThreadNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ThreadNode));</span><br><span class="line">        T-&gt;data=c;</span><br><span class="line">        <span class="built_in">CreateThTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateThTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.初始化tag*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitThread</span><span class="params">(ThreadTree&amp; T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		T-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">		T-&gt;rtag = <span class="number">0</span>;	<span class="comment">//初始化当前树中的tag指针为0，表示还未线索化</span></span><br><span class="line">		<span class="built_in">InitThread</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">InitThread</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadNode* pre = <span class="literal">NULL</span>;		<span class="comment">//pre指向当前访问结点的前驱</span></span><br><span class="line"><span class="comment">//3-1.访问并建立线索</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit1</span><span class="params">(ThreadNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">		q-&gt;lchild = pre;</span><br><span class="line">		q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;	</span><br><span class="line">		pre-&gt;rchild = q;	<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">		pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pre = q;			<span class="comment">//标记当前结点为刚刚访问过的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3-2.遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">visit1</span>(T);				<span class="comment">//先处理根节点</span></span><br><span class="line">		<span class="keyword">if</span> (T-&gt;ltag == <span class="number">0</span>)		<span class="comment">//若lchild不是前驱线索</span></span><br><span class="line">			<span class="built_in">PreThread</span>(T-&gt;lchild);	<span class="comment">//则线索化左子树</span></span><br><span class="line">		<span class="keyword">if</span> (T-&gt;rtag == <span class="number">0</span>)		<span class="comment">//若rchild不是后继线索</span></span><br><span class="line">			<span class="built_in">PreThread</span>(T-&gt;rchild);	<span class="comment">//则线索化右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3-3.主过程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">	pre = <span class="literal">NULL</span>;			<span class="comment">//pre初始化为NULL</span></span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;	<span class="comment">//非空二叉树才能线索化			</span></span><br><span class="line">		<span class="built_in">PreThread</span>(T);	<span class="comment">//先序线索化二叉树</span></span><br><span class="line">		<span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)	</span><br><span class="line">			pre-&gt;rtag = <span class="number">1</span>;			<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*4.寻找先序后继*/</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>) &#123;		<span class="comment">//若rtag=0，说明所找结点有右孩子</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>)		<span class="comment">//若ltag=0，说明所找结点有左孩子，根据先序遍历的特点(根-左-右)，左孩子为后继</span></span><br><span class="line">			<span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> p-&gt;rchild;  <span class="comment">//若ltag=1，说明所找结点无左孩子，则后继结点为其右孩子</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> p-&gt;rchild;	<span class="comment">//若rtag=1，说明所找结点无右孩子，则返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5-2.利用先序后继实现先序遍历：空间复杂度为O(1) </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(ThreadNode* T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (ThreadNode* p = T; p != <span class="literal">NULL</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line">		<span class="built_in">visit2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ThreadTree T;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序创建二叉树：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreateThTree</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitThread</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CreatePreThread</span>(T);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;根节点的先序后继为：&quot;</span>&lt;&lt;<span class="built_in">NextNode</span>(T)-&gt;data&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序遍历：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">PreOrder</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 线索二叉树(后序) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树(后序)</span></span><br><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// void CreateThTree(ThreadTree&amp; T);			//1.先序建立线索二叉树</span></span><br><span class="line"><span class="comment">// void InitThread(ThreadTree&amp; T);				//2.初始化tag</span></span><br><span class="line"><span class="comment">// void visit1(ThreadNode* q);					//3-1.访问并建立线索</span></span><br><span class="line"><span class="comment">// void PostThread(ThreadTree T);				//3-2.遍历</span></span><br><span class="line"><span class="comment">// void CreatePostThread(ThreadTree T);		//3-3.后序线索化主过程</span></span><br><span class="line"><span class="comment">// ThreadNode* PreNode(ThreadNode* p);			//4.找到p的前驱结点</span></span><br><span class="line"><span class="comment">// void visit2(ThreadNode* p);					//5-1.打印结点</span></span><br><span class="line"><span class="comment">// void RevPostOrder(ThreadNode* T);			//5-2.利用后序前驱实现逆向后序遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">	ElemType data;							<span class="comment">//数据元素</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ThreadNode</span>* lchild, * rchild;	<span class="comment">//左、右孩子指针</span></span><br><span class="line">	<span class="type">int</span> ltag, rtag;							<span class="comment">//左、右线索标志</span></span><br><span class="line">	<span class="comment">//tag=0,表示指针指向孩子;tag=1,表示指针是“线索”,ltag指向前驱，rtag指向后继</span></span><br><span class="line">&#125;ThreadNode, * ThreadTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateThTree</span><span class="params">(ThreadTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=(ThreadNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ThreadNode));</span><br><span class="line">        T-&gt;data=c;</span><br><span class="line">        <span class="built_in">CreateThTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateThTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.初始化tag*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitThread</span><span class="params">(ThreadTree&amp; T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		T-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">		T-&gt;rtag = <span class="number">0</span>;	<span class="comment">//初始化当前树中的tag指针为0，表示还未线索化</span></span><br><span class="line">		<span class="built_in">InitThread</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">InitThread</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadNode* pre = <span class="literal">NULL</span>;		<span class="comment">//pre指向当前访问结点的前驱</span></span><br><span class="line"><span class="comment">//3-1.访问并建立线索</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit1</span><span class="params">(ThreadNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">		q-&gt;lchild = pre;</span><br><span class="line">		q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;	</span><br><span class="line">		pre-&gt;rchild = q;	<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">		pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pre = q;			<span class="comment">//标记当前结点为刚刚访问过的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">visit1</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3-3.主过程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">	pre = <span class="literal">NULL</span>;			<span class="comment">//pre初始化为NULL</span></span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;	<span class="comment">//非空二叉树才能线索化			</span></span><br><span class="line">		<span class="built_in">PostThread</span>(T);	<span class="comment">//后序线索化二叉树</span></span><br><span class="line">		<span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>)	</span><br><span class="line">			pre-&gt;rtag = <span class="number">1</span>;			<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.寻找后序前驱</span></span><br><span class="line"><span class="function">ThreadNode* <span class="title">PreNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>) &#123;		<span class="comment">//若ltag=0，说明所找结点有左孩子</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>)		<span class="comment">//若rtag=0</span></span><br><span class="line">			<span class="keyword">return</span> p-&gt;rchild;		<span class="comment">//说明所找结点有右孩子，根据后序遍历的特点(左-右-根)，右孩子为前驱</span></span><br><span class="line">		<span class="keyword">else</span>                    <span class="comment">//若rtag=1</span></span><br><span class="line">			<span class="keyword">return</span>	p-&gt;lchild;		<span class="comment">//说明所找结点无右孩子，则前驱结点为其左孩子</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> p-&gt;lchild;	<span class="comment">//若ltag=1，说明所找结点无左孩子，则返回前驱线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5-2.利用后序前驱实现逆向后序遍历：空间复杂度为O(1) </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RevPostOrder</span><span class="params">(ThreadNode* T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (ThreadNode* p = T; p != <span class="literal">NULL</span>; p = <span class="built_in">PreNode</span>(p))</span><br><span class="line">		<span class="built_in">visit2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ThreadTree T;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;先序创建二叉树：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">CreateThTree</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitThread</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CreatePostThread</span>(T);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;根节点的后序前驱为:&quot;</span>&lt;&lt;<span class="built_in">PreNode</span>(T)-&gt;data&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;逆向后序遍历:&quot;</span>;</span><br><span class="line">    <span class="built_in">RevPostOrder</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 二叉树的应用(二叉排序树) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的应用(二叉排序树)</span></span><br><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="comment">// BSTNode* BST_Search(BSTree T, ElemType key);			//1-1.查找操作-非递归</span></span><br><span class="line"><span class="comment">// BSTNode* BSTSearch(BSTree T, ElemType key);				//1-2.查找操作-递归</span></span><br><span class="line"><span class="comment">// bool BST_Insert(BSTree&amp; T, ElemType key);				//2-1.插入操作-非递归</span></span><br><span class="line"><span class="comment">// bool BSTInsert(BSTree&amp; T, ElemType key);				//2-2.插入操作-递归</span></span><br><span class="line"><span class="comment">// void Create_BST(BSTree&amp; T, ElemType arr[], int n);		//3.构造二叉排序树</span></span><br><span class="line"><span class="comment">// BSTNode* FirstNode(BSTNode* p);							//4-1.找到最左下结点</span></span><br><span class="line"><span class="comment">// BSTNode* LastNode(BSTNode* p);							//4-2.找到最右下结点</span></span><br><span class="line"><span class="comment">// BSTNode* BST_Delete1(BSTree&amp; T, ElemType key);			//4-3.删除操作-用右子树中最左下结点填充</span></span><br><span class="line"><span class="comment">// BSTNode* BST_Delete2(BSTree&amp; T, ElemType key);			//4-4.删除操作-用左子树中最右下结点填充</span></span><br><span class="line"><span class="comment">// void InOrder(BSTree T);									//5.中序遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild,*rchild;</span><br><span class="line">&#125;BSTNode,*BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1-1.查找操作-非递归(最坏空间复杂度O(1))</span></span><br><span class="line"><span class="function">BSTNode* <span class="title">BST_Search</span><span class="params">(BSTree T, ElemType key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (T != <span class="literal">NULL</span> &amp;&amp; key != T-&gt;data) &#123;	<span class="comment">//若树空或找到结点，则结束循环</span></span><br><span class="line">		<span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">			T = T-&gt;lchild;		<span class="comment">//小于，在左子树上查找</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			T = T-&gt;rchild;		<span class="comment">//大于，在右子树上查找</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1-2.查找操作-递归(最坏空间复杂度O(h),h指树的高度)</span></span><br><span class="line"><span class="function">BSTNode* <span class="title">BSTSearch</span><span class="params">(BSTree T, ElemType key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;		<span class="comment">//查找失败</span></span><br><span class="line">	<span class="keyword">if</span> (key == T-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> T;			<span class="comment">//查找成功</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">BSTSearch</span>(T-&gt;lchild, key);		<span class="comment">//小于，在左子树上查找</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">BSTSearch</span>(T-&gt;rchild, key);		<span class="comment">//大于，在右子树上查找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2-1.插入操作-非递归(最坏空间复杂度O(1))</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BST_Insert</span><span class="params">(BSTree&amp; T, ElemType key)</span> </span>&#123;</span><br><span class="line">	BSTNode* p = T;					<span class="comment">//搜索指针</span></span><br><span class="line">	BSTNode* parent = <span class="literal">NULL</span>;			<span class="comment">//p的双亲结点</span></span><br><span class="line">	<span class="keyword">while</span> (p) &#123;	<span class="comment">//找到插入位置</span></span><br><span class="line">		<span class="keyword">if</span> (key == p-&gt;data)			<span class="comment">//树中存在相同关键字的结点</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;				<span class="comment">//插入失败</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			parent = p;				<span class="comment">//保留p的双亲结点</span></span><br><span class="line">			<span class="keyword">if</span> (key &lt; p-&gt;data) 	</span><br><span class="line">				p = p-&gt;lchild;			<span class="comment">//小于，在左子树上寻找插入位置</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				p = p-&gt;rchild;			<span class="comment">//大于，在右子树上寻找插入位置</span></span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*	直接插入到p是不会改变二叉树的</span></span><br><span class="line"><span class="comment">		p = (BSTNode*)malloc(sizeof(BSTNode));		//分配存储空间</span></span><br><span class="line"><span class="comment">		p-&gt;data = key;								//放入结点值		</span></span><br><span class="line"><span class="comment">		p-&gt;lchild = p-&gt;rchild = NULL;				//左右孩子置空</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	BSTNode* s = (BSTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">	s-&gt;data = key;</span><br><span class="line">	s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!parent)			<span class="comment">//若T为空树</span></span><br><span class="line">		T = s;			<span class="comment">//将s设为根结点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; parent-&gt;data)</span><br><span class="line">		parent-&gt;lchild = s;		<span class="comment">//小于，插入pre的左子树</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		parent-&gt;rchild = s;		<span class="comment">//大于，插入pre的右子树</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;			<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2-2.插入操作-递归(最坏空间复杂度O(h),h指树的高度)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BSTInsert</span><span class="params">(BSTree&amp; T, ElemType key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;							<span class="comment">//找到要插入的位置</span></span><br><span class="line">		T = (BSTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));	<span class="comment">//分配存储空间</span></span><br><span class="line">		T-&gt;data = key;							<span class="comment">//放入结点值</span></span><br><span class="line">		T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;	        <span class="comment">//左右孩子置空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;		                        <span class="comment">//插入成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key == T-&gt;data)		<span class="comment">//树中存在相同关键字的结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;					<span class="comment">//插入失败</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data)						</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">BSTInsert</span>(T-&gt;lchild, key);		<span class="comment">//小于，在左子树上插入</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &gt; T-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">BSTInsert</span>(T-&gt;rchild, key);		<span class="comment">//大于，在右子树上插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.构造二叉排序树：按照arr[]中的关键字序列建立二叉排序树*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create_BST</span><span class="params">(BSTree&amp; T, ElemType arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	T = <span class="literal">NULL</span>;			<span class="comment">//初始T为空树		</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; n) &#123;		<span class="comment">//依次将每个关键字插入到二叉排序树中 </span></span><br><span class="line">		<span class="built_in">BSTInsert</span>(T, arr[i]);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-1.找到最左下结点，也是最小结点</span></span><br><span class="line"><span class="function">BSTNode* <span class="title">FirstNode</span><span class="params">(BSTNode* p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p)					</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;lchild)	</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-2.找到最右下结点，也是最大结点</span></span><br><span class="line"><span class="function">BSTNode* <span class="title">LastNode</span><span class="params">(BSTNode* p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;rchild)</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-3.删除操作-用右子树中最左下结点填充</span></span><br><span class="line"><span class="function">BSTNode* <span class="title">BST_Delete1</span><span class="params">(BSTree&amp; T, ElemType key)</span> </span>&#123;</span><br><span class="line">	BSTNode* tmp;</span><br><span class="line">	<span class="keyword">if</span> (!T)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到！&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">		T-&gt;lchild = <span class="built_in">BST_Delete1</span>(T-&gt;lchild, key);		<span class="comment">//小于，删除左孩子</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &gt; T-&gt;data)</span><br><span class="line">		T-&gt;rchild = <span class="built_in">BST_Delete1</span>(T-&gt;rchild, key);		<span class="comment">//大于，删除右孩子</span></span><br><span class="line">	<span class="keyword">else</span>   <span class="comment">//找到要删除的结点</span></span><br><span class="line">		<span class="keyword">if</span> (T-&gt;lchild &amp;&amp; T-&gt;rchild) &#123;	<span class="comment">//1.被删除结点右左右两个子结点</span></span><br><span class="line">			tmp = <span class="built_in">FirstNode</span>(T-&gt;rchild);		<span class="comment">//找到右子树的最左下结点填充删除结点</span></span><br><span class="line">			T-&gt;data = tmp-&gt;data;</span><br><span class="line">			T-&gt;rchild = <span class="built_in">BST_Delete1</span>(T-&gt;rchild, T-&gt;data);		<span class="comment">//在删除结点的右子树中删除最小结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	<span class="comment">//2.被删除结点有一个子结点或者都没有</span></span><br><span class="line">			tmp = T;</span><br><span class="line">			<span class="keyword">if</span> (!T-&gt;lchild)</span><br><span class="line">				T = T-&gt;rchild;		<span class="comment">//有右孩子或无子结点</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!T-&gt;rchild)</span><br><span class="line">				T = T-&gt;lchild;</span><br><span class="line">			<span class="built_in">free</span>(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4-4.删除操作-用左子树中最右下结点填充</span></span><br><span class="line"><span class="function">BSTNode* <span class="title">BST_Delete2</span><span class="params">(BSTree&amp; T, ElemType key)</span> </span>&#123;</span><br><span class="line">	BSTNode* tmp;</span><br><span class="line">	<span class="keyword">if</span> (!T)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到！&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">		T-&gt;lchild = <span class="built_in">BST_Delete2</span>(T-&gt;lchild, key);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &gt; T-&gt;data)</span><br><span class="line">		T-&gt;rchild = <span class="built_in">BST_Delete2</span>(T-&gt;rchild, key);</span><br><span class="line">	<span class="keyword">else</span>   <span class="comment">//找到要删除的结点</span></span><br><span class="line">		<span class="keyword">if</span> (T-&gt;lchild &amp;&amp; T-&gt;rchild) &#123;	<span class="comment">//1.被删除结点有左右两个子结点</span></span><br><span class="line">			tmp = <span class="built_in">LastNode</span>(T-&gt;lchild);		<span class="comment">//找到左子树的最右下结点填充删除结点</span></span><br><span class="line">			T-&gt;data = tmp-&gt;data;</span><br><span class="line">			T-&gt;lchild = <span class="built_in">BST_Delete2</span>(T-&gt;lchild, T-&gt;data);		<span class="comment">//在删除结点的左子树中删除最大结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	<span class="comment">//2.被删除结点有一个子结点或者都没有</span></span><br><span class="line">			tmp = T;</span><br><span class="line">			<span class="keyword">if</span> (!T-&gt;lchild)</span><br><span class="line">				T = T-&gt;rchild;		<span class="comment">//有右孩子或无子结点</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!T-&gt;rchild)</span><br><span class="line">				T = T-&gt;lchild;</span><br><span class="line">			<span class="built_in">free</span>(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BSTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BSTree T;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">19</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">50</span>,<span class="number">26</span>,<span class="number">21</span>,<span class="number">30</span>,<span class="number">66</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">63</span>,<span class="number">61</span>,<span class="number">65</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Create_BST</span>(T,arr,<span class="number">14</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;构造二叉排序树：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">InOrder</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;二叉排序树递归插入元素&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">BSTInsert</span>(T,<span class="number">62</span>))&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T);</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;树中已存在相同结点，插入失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;二叉排序树非递归插入元素&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">BST_Insert</span>(T,<span class="number">67</span>))&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T);</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;树中已存在相同结点，插入失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;删除指定元素-右子树最左下结点填充&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">BST_Delete1</span>(T,<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">InOrder</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;删除指定元素-左子树最右下结点填充&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">BST_Insert</span>(T,<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">BST_Delete2</span>(T,<span class="number">60</span>);</span><br><span class="line">    <span class="built_in">InOrder</span>(T);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details>
              </div>
            </details>
<h1 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序-sort"></a>排序-sort</h1><details class="folding-tag" yellow><summary> 排序 </summary>
              <div class='content'>
              <details class="folding-tag" blue><summary> 顺序查找 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitTable</span><span class="params">(SSTable &amp;ST)</span></span>&#123;</span><br><span class="line">    ST.elem=(ElemType *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*InitSize);</span><br><span class="line">    ST.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AssignTbble</span><span class="params">(SSTable &amp;ST)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    ElemType x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ST.length&gt;InitSize<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ST.elem[i]=x;</span><br><span class="line">        ST.length++;</span><br><span class="line">        i++;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ST.elem[<span class="number">0</span>]=key;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.length;ST.elem[i]!=key;--i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    <span class="built_in">InitTable</span>(ST);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;顺序表赋值开始，请依次输入元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">AssignTbble</span>(ST))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入元素个数大于顺序表长度，赋值失败！&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前顺序表的长度为：&quot;</span>&lt;&lt;ST.length&lt;&lt;endl;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入要查找的值：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;key;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">Search_Seq</span>(ST,key))</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;当前顺序表中无此元素！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;您要查找的元素所在位序为:&quot;</span>&lt;&lt;<span class="built_in">Search_Seq</span>(ST,key)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 折半查找 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType elem[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AssignList</span><span class="params">(SeqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    ElemType x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.length&gt;=MaxSize)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        L.elem[i]=x;</span><br><span class="line">        L.length++;</span><br><span class="line">        i++;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(SeqList L,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>,high=L.length<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid]==key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SeqList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;顺序表赋值开始，请依次输入元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">AssignList</span>(L))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入元素个数大于顺序表长度，赋值失败！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前顺序表的长度为:&quot;</span>&lt;&lt;L.length&lt;&lt;endl;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入要查找的值：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;key;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Binary_Search</span>(L,key)==<span class="number">-1</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;查找值失败！当前顺序表无此元素！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;查找的元素所在数组下标为：&quot;</span>&lt;&lt;<span class="built_in">Binary_Search</span>(L,key)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 内部排序(插入排序) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELemType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectInsertSort</span><span class="params">(ELemType A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;</span><br><span class="line">            A[<span class="number">0</span>]=A[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];j--)</span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">            A[j+<span class="number">1</span>]=A[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//折半查找排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HalfInsertSort</span><span class="params">(ELemType A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        A[<span class="number">0</span>]=A[i];</span><br><span class="line">        low=<span class="number">1</span>;</span><br><span class="line">        high=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>])</span><br><span class="line">                high=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;j--)</span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(ELemType A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> d,i,j;</span><br><span class="line">    <span class="keyword">for</span>(d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d/=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-d])&#123;</span><br><span class="line">                A[<span class="number">0</span>]=A[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=d)</span><br><span class="line">                    A[j+d]=A[j];</span><br><span class="line">                A[j+d]=A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//直接插入排序</span></span><br><span class="line">    ELemType A[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">11</span>;i++)</span><br><span class="line">        cin&gt;&gt;A[i];</span><br><span class="line">    <span class="built_in">DirectInsertSort</span>(A,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">11</span>;i++)</span><br><span class="line">        cout&lt;&lt;A[i]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//折半插入排序</span></span><br><span class="line">    ELemType B[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">11</span>;i++)</span><br><span class="line">        cin&gt;&gt;B[i];</span><br><span class="line">    <span class="built_in">HalfInsertSort</span>(B,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">11</span>;i++)</span><br><span class="line">        cout&lt;&lt;B[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//希尔排序</span></span><br><span class="line">    ELemType C[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        cin&gt;&gt;C[i];</span><br><span class="line">    <span class="built_in">ShellSort</span>(C,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        cout&lt;&lt;C[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 内部排序(交换排序) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELemType int </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bubblesort</span><span class="params">(ELemType A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;</span><br><span class="line">                <span class="built_in">Swap</span>(A[j<span class="number">-1</span>],A[j]);</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(ELemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    ELemType pivot=A[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot)</span><br><span class="line">            high--;</span><br><span class="line">        A[low]=A[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot)</span><br><span class="line">            low++;</span><br><span class="line">        A[high]=A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(ELemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> pivotpos=<span class="built_in">Partition</span>(A,low,high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ELemType A[]=&#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">Bubblesort</span>(A,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        cout&lt;&lt;A[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    ELemType B[]=&#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">QuickSort</span>(B,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        cout&lt;&lt;B[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 内部排序(选择排序) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1-2.简单选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;		<span class="comment">//一共进行n-1趟排序</span></span><br><span class="line">		<span class="type">int</span> min = i;						<span class="comment">//记录最小元素位置</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)		<span class="comment">//再A[i...n-1]中选择最小元素</span></span><br><span class="line">			<span class="keyword">if</span> (A[j] &lt; A[min])				</span><br><span class="line">				min = j;					<span class="comment">//更新最小元素的位置</span></span><br><span class="line">		<span class="keyword">if</span> (min != i)						</span><br><span class="line">			<span class="built_in">swap</span>(A[i], A[min]);				<span class="comment">//封装的swap函数共移动元素3次		</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintA</span><span class="params">(ElemType A[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        cout&lt;&lt;A[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2-1.堆调整(以大根堆为例)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(ElemType A[], <span class="type">int</span> k, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//函数HeadAdjust将元素k为根的子树进行调整</span></span><br><span class="line">	A[<span class="number">0</span>] = A[k];	<span class="comment">//A[0]暂存子树的根结点								</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * k; i &lt;= len; i *= <span class="number">2</span>) &#123;	<span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; len &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>])		<span class="comment">//子树根结点的左右孩子</span></span><br><span class="line">			i++;							<span class="comment">//取key较大的孩子的下标</span></span><br><span class="line">		<span class="keyword">if</span> (A[<span class="number">0</span>] &gt;= A[i])					</span><br><span class="line">			<span class="keyword">break</span>;							<span class="comment">//若子树的根结点大于左右孩子，不必调整</span></span><br><span class="line">		<span class="keyword">else</span> &#123;								<span class="comment">//否则</span></span><br><span class="line">			A[k] = A[i];					<span class="comment">//A[i]提到子树的根结点</span></span><br><span class="line">			k = i;							<span class="comment">//修改k值，继续向下筛选</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	A[k] = A[<span class="number">0</span>];							<span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2-2.建立大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)	<span class="comment">//从i=[n/2]~1,反复调整堆</span></span><br><span class="line">		<span class="built_in">HeadAdjust</span>(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2-3.堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">BuildMaxHeap</span>(A, len);				<span class="comment">//建立大根堆</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt; <span class="number">1</span>; i--) &#123;		<span class="comment">//n-1趟的交换和调整过程</span></span><br><span class="line">		<span class="built_in">swap</span>(A[i], A[<span class="number">1</span>]);				<span class="comment">//输出堆顶元素(和堆底元素交换)</span></span><br><span class="line">		<span class="built_in">HeadAdjust</span>(A, <span class="number">1</span>, i - <span class="number">1</span>);		<span class="comment">//调整，把剩余的i-1个元素整理成堆</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2-4.输出测试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintB</span><span class="params">(ElemType B[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len + <span class="number">1</span>; i++)	</span><br><span class="line">		cout&lt;&lt;B[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ElemType A[] = &#123; <span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SelectSort</span>(A, <span class="number">8</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;简单选择排序&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">PrintA</span>(A, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*2、堆排序*/</span></span><br><span class="line">	ElemType B[] = &#123; <span class="number">-1</span>,<span class="number">53</span>,<span class="number">17</span>,<span class="number">78</span>,<span class="number">9</span>,<span class="number">45</span>,<span class="number">65</span>,<span class="number">87</span>,<span class="number">32</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2-1.建立大根堆</span></span><br><span class="line">	<span class="built_in">BuildMaxHeap</span>(B, <span class="number">8</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;建立大根堆&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">PrintB</span>(B, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2-2.堆排序</span></span><br><span class="line">	<span class="built_in">HeapSort</span>(B, <span class="number">8</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;堆排序&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">PrintB</span>(B, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 内部排序(归并排序) </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.归并</span></span><br><span class="line">ElemType* B = (ElemType*)<span class="built_in">malloc</span>((LEN) * <span class="built_in">sizeof</span>(ElemType));		<span class="comment">//辅助数组B</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//表A的两段A[low...mid]和A[mid+1...high]各自有序，将它们合并成一个有序表</span></span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (k = low; k &lt;= high; k++)</span><br><span class="line">		B[k] = A[k];				<span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">	<span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (B[i] &lt;= B[j])			<span class="comment">//比较B的左右两段中的元素</span></span><br><span class="line">			A[k] = B[i++];			<span class="comment">//将较小值复制到A中</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			A[k] = B[j++];</span><br><span class="line">	&#125;<span class="comment">//for</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">		A[k++] = B[i++];	<span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">		A[k++] = B[j++];	<span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.归并主过程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high) &#123;	</span><br><span class="line">		<span class="type">int</span> mid = (low + high) / <span class="number">2</span>;		<span class="comment">//从中间划分两个子序列</span></span><br><span class="line">		<span class="built_in">MergeSort</span>(A, low, mid);			<span class="comment">//对左侧子序列进行递归排序</span></span><br><span class="line">		<span class="built_in">MergeSort</span>(A, mid + <span class="number">1</span>, high);	<span class="comment">//对右侧子序列进行递归排序</span></span><br><span class="line">		<span class="built_in">Merge</span>(A, low, mid, high);		<span class="comment">//归并</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(ElemType A[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		cout&lt;&lt;A[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ElemType A[] = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>&#125;;</span><br><span class="line">	<span class="built_in">MergeSort</span>(A, <span class="number">0</span>, LEN<span class="number">-1</span>);	</span><br><span class="line">	<span class="built_in">Print</span>(A, LEN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details>
              </div>
            </details></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Johnson-Yhy🍭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81/">http://example.com/2023/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Johnson-Yhy🥝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%F0%9F%A5%A7c-plus-plus/">🥧c plus plus</a></div><div class="post_share"><div class="social-share" data-image="https://images7.alphacoders.com/130/1306240.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/07/02/C-%E6%95%99%E7%A8%8B/" title="C++教程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images2.alphacoders.com/127/thumbbig-1274969.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++教程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/02/C-%E6%95%99%E7%A8%8B/" title="C++教程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images2.alphacoders.com/127/thumbbig-1274969.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-02</div><div class="title">C++教程</div></div></a></div><div><a href="/2023/07/01/STL%E6%95%99%E7%A8%8B/" title="STL教程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images4.alphacoders.com/710/thumbbig-710501.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-01</div><div class="title">STL教程</div></div></a></div><div><a href="/2023/06/28/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/" title="刷题日记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images2.alphacoders.com/127/thumbbig-1274969.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-28</div><div class="title">刷题日记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div></div><div class="author-info__name">Johnson-Yhy🍭</div><div class="author-info__description">压力来自于fucking无法自律</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>前往小家……<i class="faa-passing animated" style="padding-left:20px;display:inline-block;vertical-align:middle;"><svg class="icon" style="height:28px;width:28px;fill:currentColor;position:relative;top:5px"><use xlink:href="#icon-xiaoqiche"></use></svg></i></span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Johnson-Yhy" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:johnson_yhy@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客💕！</div><div id="welcome-info"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8-Sequence-table"><span class="toc-text">顺序表-Sequence table</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8-LinkList"><span class="toc-text">链表-LinkList</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97-Stack-amp-amp-Queue"><span class="toc-text">栈和队列-Stack &amp;&amp; Queue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2-String"><span class="toc-text">串-String</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91-Tree"><span class="toc-text">树-Tree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-sort"><span class="toc-text">排序-sort</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81/" title="Data-Struct code"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images7.alphacoders.com/130/1306240.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Data-Struct code"/></a><div class="content"><a class="title" href="/2023/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81/" title="Data-Struct code">Data-Struct code</a><time datetime="2023-10-14T16:00:00.000Z" title="发表于 2023-10-15 00:00:00">2023-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/02/C-%E6%95%99%E7%A8%8B/" title="C++教程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images2.alphacoders.com/127/thumbbig-1274969.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++教程"/></a><div class="content"><a class="title" href="/2023/07/02/C-%E6%95%99%E7%A8%8B/" title="C++教程">C++教程</a><time datetime="2023-07-01T16:00:00.000Z" title="发表于 2023-07-02 00:00:00">2023-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/02/%E5%8C%BB%E9%99%A2%E5%B1%80%E5%9F%9F%E7%BD%91%E8%A7%84%E5%88%92/" title="医院局域网规划"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images4.alphacoders.com/710/thumbbig-710501.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="医院局域网规划"/></a><div class="content"><a class="title" href="/2023/07/02/%E5%8C%BB%E9%99%A2%E5%B1%80%E5%9F%9F%E7%BD%91%E8%A7%84%E5%88%92/" title="医院局域网规划">医院局域网规划</a><time datetime="2023-07-01T16:00:00.000Z" title="发表于 2023-07-02 00:00:00">2023-07-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">🧬🧬🧬</p></div></div></div></div><div class="copyright"><span><b>&copy;2023</b></span><span><b>&nbsp;&nbsp;By Johnson-Yhy🍭</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20237009" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20237009号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.bitiful.net/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0</span><span>%</span></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script async src="/js/fps.js"></script><script src="/js/snow.js"></script><script defer src="/js/cursor.js"></script><script defer src="/js/runtime.js"></script><div><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas></div><script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script><script async type="text/javascript" src="https://cdn.jsdelivr.net/gh/Candinya/Kratos-Rebirth@latest/source/js/snow.min.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script src="/js/VolantisTags.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>